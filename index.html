<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>thIAguinho WII: ULTIMATE ARCADE</title>
    
    <!-- TensorFlow.js Dependencies (Core Est√°vel) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Russo+One&display=swap');

        body {
            background-color: #000;
            margin: 0;
            overflow: hidden;
            font-family: 'Russo One', sans-serif;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* V√çDEO (ESPELHO VISUAL) */
        #webcam {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* O usu√°rio se v√™ no espelho */
            filter: brightness(0.5) contrast(1.1); /* Escurecido para o jogo brilhar */
            z-index: 0;
        }

        /* CAMADA DO JOGO */
        #game-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
        }

        /* UI */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; pointer-events: none;
        }

        .interactive { pointer-events: auto !important; }

        /* ESTILOS DE TEXTO E HUD */
        .title-glitch {
            text-shadow: 2px 2px 0px #00F3FF, -2px -2px 0px #FF0055;
            animation: glitch 1s infinite alternate;
        }
        @keyframes glitch {
            0% { transform: skew(0deg); }
            20% { transform: skew(-1deg); }
            40% { transform: skew(1deg); }
            100% { transform: skew(0deg); }
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 15px #00F3FF;
            backdrop-filter: blur(8px);
            border-radius: 12px;
        }

        .btn-arcade {
            background: linear-gradient(180deg, #222 0%, #111 100%);
            border: 2px solid #444;
            box-shadow: 0 4px 0 #000;
            transition: all 0.1s;
            position: relative;
            overflow: hidden;
        }
        .btn-arcade:active { transform: translateY(4px); box-shadow: 0 0 0 #000; }
        
        .btn-arcade.kart:hover { border-color: #00F3FF; box-shadow: 0 0 20px #00F3FF; }
        .btn-arcade.run:hover { border-color: #00FF9D; box-shadow: 0 0 20px #00FF9D; }
        .btn-arcade.box:hover { border-color: #FF0055; box-shadow: 0 0 20px #FF0055; }

        /* FEEDBACK VISUAL */
        #hit-feedback {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem; color: white;
            text-shadow: 0 0 20px white;
            opacity: 0; pointer-events: none;
            transition: opacity 0.1s;
            z-index: 50;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- V√çDEO -->
        <video id="webcam" autoplay muted playsinline></video>
        <!-- CANVAS -->
        <canvas id="game-canvas"></canvas>

        <!-- UI -->
        <div id="ui-layer" class="flex flex-col items-center justify-between p-6">
            
            <!-- LOADER -->
            <div id="screen-loading" class="absolute inset-0 bg-black z-50 flex flex-col items-center justify-center interactive">
                <h1 class="text-4xl text-cyan-400 font-black tracking-widest mb-4">thIAguinho WII</h1>
                <div class="w-64 h-2 bg-gray-800 rounded overflow-hidden">
                    <div id="loading-bar" class="h-full bg-cyan-400 w-0 transition-all duration-300"></div>
                </div>
                <p id="loading-text" class="text-gray-500 text-xs mt-2 uppercase">Inicializando Sensores...</p>
            </div>

            <!-- MENU PRINCIPAL -->
            <div id="screen-menu" class="hidden absolute inset-0 bg-black/90 backdrop-blur-md z-40 flex flex-col items-center justify-center interactive">
                <div class="mb-12 text-center">
                    <h1 class="text-6xl md:text-8xl text-white font-black title-glitch leading-none">
                        th<span class="text-cyan-400">IA</span>guinho<br>WII
                    </h1>
                    <p class="text-gray-400 tracking-[0.5em] text-sm mt-2">ULTIMATE COLLECTION</p>
                </div>
                
                <div class="flex flex-col md:flex-row gap-6 w-full max-w-4xl px-8">
                    <!-- KART -->
                    <button onclick="App.start('kart')" class="btn-arcade kart flex-1 h-64 rounded-2xl flex flex-col items-center justify-center group">
                        <div class="text-6xl mb-4 group-hover:scale-110 transition-transform">üèéÔ∏è</div>
                        <h2 class="text-2xl font-bold text-white">AR KART</h2>
                        <p class="text-xs text-gray-400 mt-2">Segure o Volante</p>
                    </button>

                    <!-- RUN -->
                    <button onclick="App.start('run')" class="btn-arcade run flex-1 h-64 rounded-2xl flex flex-col items-center justify-center group">
                        <div class="text-6xl mb-4 group-hover:scale-110 transition-transform">üèÉ</div>
                        <h2 class="text-2xl font-bold text-white">STREET RUN</h2>
                        <p class="text-xs text-gray-400 mt-2">Corra e Pule</p>
                    </button>

                    <!-- BOX -->
                    <button onclick="App.start('box')" class="btn-arcade box flex-1 h-64 rounded-2xl flex flex-col items-center justify-center group">
                        <div class="text-6xl mb-4 group-hover:scale-110 transition-transform">ü•ä</div>
                        <h2 class="text-2xl font-bold text-white">RHYTHM BOX</h2>
                        <p class="text-xs text-gray-400 mt-2">Soque no Ritmo</p>
                    </button>
                </div>
                
                <p class="text-gray-600 text-[10px] mt-8">Posicione o celular na horizontal ou vertical (Auto-Adapt√°vel)</p>
            </div>

            <!-- HUD (IN-GAME) -->
            <div id="screen-hud" class="hidden w-full flex-col justify-between h-full pointer-events-none">
                <!-- Topo -->
                <div class="flex justify-between items-start w-full">
                    <div class="hud-panel px-4 py-2 flex flex-col">
                        <span class="text-[10px] text-cyan-400 uppercase tracking-widest">SCORE</span>
                        <span id="hud-score" class="text-3xl font-mono font-bold text-white leading-none">0</span>
                    </div>
                    
                    <button onclick="App.stop()" class="interactive w-12 h-12 rounded-full bg-red-600/20 border-2 border-red-500 text-red-500 font-bold flex items-center justify-center backdrop-blur hover:bg-red-600 hover:text-white transition-all">
                        ‚úï
                    </button>
                </div>

                <!-- Centro (Feedback) -->
                <div id="hit-feedback"></div>

                <!-- Base (Instru√ß√µes/Status) -->
                <div class="flex justify-center w-full pb-4">
                    <div id="hud-status" class="hud-panel px-6 py-2 text-sm text-white font-bold uppercase tracking-wider">
                        AGUARDANDO...
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
        /**
         * =========================================================================
         * ENGINE GR√ÅFICA (Visual Procedural 2.5D)
         * =========================================================================
         */
        const Gfx = {
            canvas: document.getElementById('game-canvas'),
            ctx: null,
            width: 0, height: 0,

            init: () => {
                Gfx.ctx = Gfx.canvas.getContext('2d', { alpha: true });
                window.addEventListener('resize', Gfx.resize);
                Gfx.resize();
            },

            resize: () => {
                const dpr = window.devicePixelRatio || 1;
                Gfx.width = window.innerWidth;
                Gfx.height = window.innerHeight;
                Gfx.canvas.width = Gfx.width * dpr;
                Gfx.canvas.height = Gfx.height * dpr;
                Gfx.ctx.scale(dpr, dpr);
            },

            clear: () => Gfx.ctx.clearRect(0, 0, Gfx.width, Gfx.height),

            // Utilit√°rio: Desenha o Volante Virtual
            drawSteeringWheel: (angle, active) => {
                const cx = Gfx.width / 2;
                const cy = 120; // Posi√ß√£o fixa no topo
                const r = 60;
                const ctx = Gfx.ctx;

                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(angle);

                // Aro
                ctx.beginPath(); ctx.arc(0,0, r, 0, Math.PI*2);
                ctx.lineWidth = 10; 
                ctx.strokeStyle = active ? '#00F3FF' : 'rgba(255,255,255,0.3)';
                ctx.stroke();

                // Raios
                ctx.beginPath(); ctx.moveTo(-r, 0); ctx.lineTo(r, 0);
                ctx.moveTo(0, 0); ctx.lineTo(0, r);
                ctx.lineWidth = 6; ctx.stroke();

                ctx.restore();
            },

            // Utilit√°rio: Desenha Esqueleto
            drawSkeleton: (pose, color) => {
                if (!pose) return;
                const ctx = Gfx.ctx;
                ctx.save();
                ctx.strokeStyle = color; ctx.lineWidth = 4; ctx.lineCap = 'round';
                
                const path = (p1, p2) => {
                    if (p1.score > 0.3 && p2.score > 0.3) {
                        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                    }
                };
                
                path(pose.shoulders.l, pose.shoulders.r);
                path(pose.shoulders.l, pose.elbows.l); path(pose.elbows.l, pose.wrists.l);
                path(pose.shoulders.r, pose.elbows.r); path(pose.elbows.r, pose.wrists.r);
                
                ctx.restore();
            }
        };

        /**
         * =========================================================================
         * MOTION ENGINE (Corre√ß√£o de Espelho e F√≠sica)
         * =========================================================================
         */
        const Motion = {
            detector: null,
            video: document.getElementById('webcam'),
            prevPose: null,
            lastTime: 0,

            init: async () => {
                const loadBar = document.getElementById('loading-bar');
                const loadTxt = document.getElementById('loading-text');
                
                try {
                    await tf.setBackend('webgl');
                    loadBar.style.width = '30%'; loadTxt.innerText = "Acessando C√¢mera...";
                    
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } },
                        audio: false
                    });
                    Motion.video.srcObject = stream;
                    await new Promise(r => Motion.video.onloadedmetadata = r);
                    Motion.video.play();

                    loadBar.style.width = '70%'; loadTxt.innerText = "Carregando MoveNet...";
                    const config = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING };
                    Motion.detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, config);
                    
                    loadBar.style.width = '100%';
                    return true;
                } catch (e) {
                    alert("Erro: C√¢mera n√£o permitida ou HTTPS ausente.");
                    return false;
                }
            },

            getPose: async () => {
                if (!Motion.detector) return null;
                
                const now = performance.now();
                const dt = Math.min((now - Motion.lastTime)/1000, 0.1);
                Motion.lastTime = now;

                const poses = await Motion.detector.estimatePoses(Motion.video);
                if (poses.length === 0) return null;

                const raw = poses[0].keypoints;
                const vw = Motion.video.videoWidth;
                const vh = Motion.video.videoHeight;
                const sw = Gfx.width;
                const sh = Gfx.height;

                // Scale Cover
                const scale = Math.max(sw / vw, sh / vh);
                const ox = (sw - (vw * scale)) / 2;
                const oy = (sh - (vh * scale)) / 2;

                // CORRE√á√ÉO DE ESPELHAMENTO: X = Width - Calculado
                const map = (kp) => ({
                    x: sw - (((vw - kp.x) * scale) + ox), 
                    y: (kp.y * scale) + oy,
                    score: kp.score
                });

                const find = (n) => raw.find(k => k.name === n);
                
                const nose = map(find('nose'));
                const ls = map(find('left_shoulder')); const rs = map(find('right_shoulder'));
                const lw = map(find('left_wrist')); const rw = map(find('right_wrist'));
                const le = map(find('left_elbow')); const re = map(find('right_elbow'));

                // Largura do corpo (Refer√™ncia m√©trica)
                const bodyWidth = (ls.score > 0.3 && rs.score > 0.3) 
                    ? Math.hypot(ls.x - rs.x, ls.y - rs.y) 
                    : (Motion.prevPose ? Motion.prevPose.bodyWidth : 100);

                const pose = {
                    nose, 
                    shoulders: { l: ls, r: rs },
                    wrists: { l: lw, r: rw },
                    elbows: { l: le, r: re },
                    center: { x: (ls.x + rs.x)/2, y: (ls.y + rs.y)/2 },
                    bodyWidth,
                    dt
                };

                // Suaviza√ß√£o (Lerp)
                if (Motion.prevPose) {
                    const alpha = 0.5; // 50% novo, 50% velho
                    const smooth = (c, p) => c * alpha + p * (1-alpha);
                    pose.center.y = smooth(pose.center.y, Motion.prevPose.center.y);
                    pose.wrists.l.x = smooth(pose.wrists.l.x, Motion.prevPose.wrists.l.x);
                    pose.wrists.l.y = smooth(pose.wrists.l.y, Motion.prevPose.wrists.l.y);
                    pose.wrists.r.x = smooth(pose.wrists.r.x, Motion.prevPose.wrists.r.x);
                    pose.wrists.r.y = smooth(pose.wrists.r.y, Motion.prevPose.wrists.r.y);
                }
                
                Motion.prevPose = pose;
                return pose;
            }
        };

        /**
         * =========================================================================
         * JOGO 1: AR KART (VOLANTE REALISTA)
         * =========================================================================
         */
        class GameKart {
            constructor() {
                this.speed = 0;
                this.angle = 0;
                this.carX = 0;
                this.curve = 0;
                this.score = 0;
                this.obstacles = [];
                this.handsActive = false;
                document.getElementById('hud-status').innerText = "LEVANTE AS M√ÉOS PARA DIRIGIR";
            }

            update(pose, ctx, w, h) {
                // L√ìGICA DO VOLANTE
                let steerInput = 0;
                this.handsActive = false;

                if (pose.wrists.l.score > 0.4 && pose.wrists.r.score > 0.4) {
                    const midY = (pose.wrists.l.y + pose.wrists.r.y) / 2;
                    // M√£os devem estar na metade superior
                    if (midY < h * 0.6) {
                        this.handsActive = true;
                        
                        // √Çngulo entre pulsos
                        const dy = pose.wrists.r.y - pose.wrists.l.y;
                        const dx = pose.wrists.r.x - pose.wrists.l.x;
                        const rawAngle = Math.atan2(dy, dx);
                        
                        // Compensar inclina√ß√£o dos ombros
                        const sDy = pose.shoulders.r.y - pose.shoulders.l.y;
                        const sDx = pose.shoulders.r.x - pose.shoulders.l.x;
                        const bodyAngle = Math.atan2(sDy, sDx);

                        steerInput = rawAngle - bodyAngle;
                        // Deadzone & Clamp
                        if (Math.abs(steerInput) < 0.1) steerInput = 0;
                        steerInput = Math.max(-1.2, Math.min(1.2, steerInput));

                        // Acelera√ß√£o
                        this.speed = Math.min(150, this.speed + 60 * pose.dt);
                    }
                }

                if (!this.handsActive) {
                    this.speed *= 0.95; // Freio
                    steerInput = 0; // Retorno ao centro
                }

                // Suaviza√ß√£o do volante
                this.angle += (steerInput - this.angle) * 5 * pose.dt;

                // F√≠sica do Carro
                this.curve = Math.sin(Date.now() / 1500) * 0.6; 
                const turnForce = this.angle * 3.5;
                const centrifugal = this.curve * (this.speed / 100);
                this.carX += (turnForce - centrifugal) * pose.dt;
                
                // Limites
                if (this.carX < -1.5) { this.carX = -1.5; this.speed *= 0.8; }
                if (this.carX > 1.5) { this.carX = 1.5; this.speed *= 0.8; }

                this.score += Math.floor(this.speed * pose.dt);

                // Obst√°culos
                if (Math.random() < 0.02 && this.speed > 30) this.obstacles.push({x: (Math.random()-0.5)*2.5, z: 0});

                // RENDER
                ctx.clearRect(0,0,w,h);
                
                // Pista
                const horizon = h * 0.4;
                ctx.fillStyle = '#111'; 
                ctx.beginPath();
                const cTop = w/2 + (this.curve * 200);
                const cBot = w/2 + (this.carX * -300);
                
                ctx.moveTo(cTop - 10, horizon); ctx.lineTo(cTop + 10, horizon);
                ctx.lineTo(cBot + w*1.5, h); ctx.lineTo(cBot - w*1.5, h);
                ctx.fill();

                // Linhas Neon
                ctx.strokeStyle = '#00F3FF'; ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(cTop - 10, horizon); ctx.lineTo(cBot - w*1.5, h);
                ctx.moveTo(cTop + 10, horizon); ctx.lineTo(cBot + w*1.5, h);
                ctx.stroke();

                // Obst√°culos
                this.obstacles.forEach((obs, i) => {
                    obs.z += (this.speed * 0.002) * pose.dt * 60;
                    if (obs.z > 1.2) { this.obstacles.splice(i,1); return; }

                    const drawY = horizon + (obs.z * (h - horizon));
                    const roadX = cTop + (cBot - cTop) * obs.z;
                    const drawX = roadX + (obs.x * w * 0.5 * obs.z);
                    const size = 40 * obs.z * obs.z;

                    ctx.fillStyle = '#FF0055';
                    ctx.fillRect(drawX - size/2, drawY - size, size, size);

                    if (obs.z > 0.85 && obs.z < 0.95 && Math.abs(drawX - w/2) < 80) {
                        this.speed = 10;
                        App.showHit("BATIDA!");
                        ctx.fillStyle = 'white'; ctx.fillRect(0,0,w,h);
                    }
                });

                // Carro
                const carY = h - 150;
                ctx.save();
                ctx.translate(w/2, carY);
                ctx.rotate(this.angle * 0.3);
                ctx.fillStyle = '#00F3FF';
                ctx.beginPath(); ctx.roundRect(-60, -30, 120, 60, 10); ctx.fill();
                ctx.fillStyle = '#FF0055'; 
                ctx.beginPath(); ctx.arc(-40, 0, 12, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(40, 0, 12, 0, Math.PI*2); ctx.fill();
                ctx.restore();

                // Volante Guia
                Gfx.drawSteeringWheel(this.angle, this.handsActive);
                Gfx.drawSkeleton(pose, this.handsActive ? '#00F3FF' : '#555');

                return this.score;
            }
        }

        /**
         * =========================================================================
         * JOGO 2: STREET RUN (CAD√äNCIA REAL)
         * =========================================================================
         */
        class GameRun {
            constructor() {
                this.score = 0;
                this.speed = 0;
                this.lane = 0; // -1, 0, 1
                this.playerY = 0;
                this.jumpVel = 0;
                this.obstacles = [];
                this.lastShoulderY = 0;
                this.runEnergy = 0;
                document.getElementById('hud-status').innerText = "CORRA NO LUGAR PARA MOVER";
            }

            update(pose, ctx, w, h) {
                if (pose.shoulders.l.score > 0.4) {
                    const midX = pose.center.x;
                    const midY = pose.center.y;

                    // Dire√ß√£o (Posi√ß√£o lateral do corpo)
                    const diffX = midX - (w/2);
                    if (diffX < -w*0.1) this.lane = -1;
                    else if (diffX > w*0.1) this.lane = 1;
                    else this.lane = 0;

                    // Corrida (Oscila√ß√£o Vertical)
                    if (!this.lastShoulderY) this.lastShoulderY = midY;
                    const delta = Math.abs(midY - this.lastShoulderY);
                    this.lastShoulderY = midY;

                    const activity = delta / pose.bodyWidth; // Normalizado
                    if (activity > 0.03) this.runEnergy = Math.min(1, this.runEnergy + 2.0 * pose.dt);
                    else this.runEnergy = Math.max(0, this.runEnergy - 1.5 * pose.dt);
                    
                    this.speed = this.runEnergy * 70;

                    // Pulo
                    if (this.playerY === 0 && (midY < this.lastShoulderY - 10)) { // Subiu r√°pido
                         // Detectar impulso positivo futuro na pr√≥xima itera√ß√£o ou usar delta simples
                    }
                    // Simplifica√ß√£o: Se o corpo estiver muito acima da calibra√ß√£o inicial (futuro)
                    // Por enquanto: Pulo por bot√£o ou gesto brusco.
                    // Vamos usar "Bra√ßos pra cima" para pular por confiabilidade
                    if (pose.wrists.l.y < pose.nose.y && this.playerY === 0) {
                        this.jumpVel = 20; this.playerY = 1; App.showHit("PULO!");
                    }
                }

                // F√≠sica
                this.score += Math.floor(this.speed * pose.dt);
                if (this.playerY > 0) {
                    this.playerY += this.jumpVel * pose.dt * 2;
                    this.jumpVel -= 60 * pose.dt;
                    if (this.playerY <= 0) { this.playerY = 0; this.jumpVel = 0; }
                }

                // Obst√°culos
                if (Math.random() < 0.02 && this.speed > 5) this.obstacles.push({lane: Math.floor(Math.random()*3)-1, z: 0});

                // RENDER
                ctx.clearRect(0,0,w,h);
                const horizon = h * 0.4;
                ctx.fillStyle = '#222'; 
                ctx.beginPath(); ctx.moveTo(w/2, horizon); ctx.lineTo(w*1.5, h); ctx.lineTo(-w*0.5, h); ctx.fill();

                // Linhas
                ctx.strokeStyle = '#00FF9D'; ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(w/2, horizon); ctx.lineTo(w/2, h); // Centro
                ctx.moveTo(w/2, horizon); ctx.lineTo(w*0.8, h); // Dir
                ctx.moveTo(w/2, horizon); ctx.lineTo(w*0.2, h); // Esq
                ctx.stroke();

                // Obst√°culos
                this.obstacles.forEach((obs, i) => {
                    obs.z += (this.speed * 0.005 + 0.01) * 60 * pose.dt;
                    if (obs.z > 1.2) { this.obstacles.splice(i,1); return; }

                    const scale = obs.z;
                    const roadW = w * 2 * scale;
                    const drawX = (w/2) + (obs.lane * roadW * 0.15); // Pistas
                    const drawY = horizon + (obs.z * (h - horizon));
                    const size = 50 * scale;

                    ctx.fillStyle = '#FF0055';
                    ctx.fillRect(drawX - size/2, drawY - size, size, size);

                    // Colis√£o
                    if (obs.z > 0.85 && obs.z < 0.95 && obs.lane === this.lane && this.playerY === 0) {
                        this.speed = 0; this.runEnergy = 0;
                        App.showHit("CRASH!");
                        ctx.fillStyle = 'white'; ctx.fillRect(0,0,w,h);
                        this.obstacles.splice(i,1);
                    }
                });

                // Avatar (Esqueleto)
                ctx.save();
                const jumpPx = this.playerY * -200;
                const lanePx = this.lane * 100;
                ctx.translate(lanePx, jumpPx);
                Gfx.drawSkeleton(pose, '#00FF9D');
                ctx.restore();

                return this.score;
            }
        }

        /**
         * =========================================================================
         * JOGO 3: RHYTHM BOX (BOXE)
         * =========================================================================
         */
        class GameBox {
            constructor() {
                this.score = 0;
                this.targets = [];
                this.timer = 0;
                document.getElementById('hud-status').innerText = "SOQUE AS BOLHAS COLORIDAS";
            }

            update(pose, ctx, w, h) {
                this.timer += pose.dt;
                if (this.timer > 1.0) { // Spawn
                    this.timer = 0;
                    const side = Math.random() > 0.5 ? 'left' : 'right';
                    this.targets.push({
                        x: side === 'left' ? w * 0.25 : w * 0.75,
                        y: Math.random() * (h * 0.5) + (h * 0.2),
                        r: 10,
                        active: true,
                        side: side,
                        color: side === 'left' ? '#00F3FF' : '#FF0055'
                    });
                }

                ctx.clearRect(0,0,w,h);
                Gfx.drawSkeleton(pose, '#555'); // Fundo

                this.targets.forEach(t => {
                    if (!t.active) return;
                    t.r += 80 * pose.dt;

                    // Desenha
                    ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2);
                    ctx.fillStyle = t.color + '44'; ctx.fill();
                    ctx.strokeStyle = t.color; ctx.lineWidth = 4; ctx.stroke();

                    // Hit
                    if (pose && t.r > 40) {
                        const hand = t.side === 'left' ? pose.wrists.l : pose.wrists.r;
                        const dist = Math.hypot(hand.x - t.x, hand.y - t.y);
                        
                        if (dist < t.r + 30) {
                            t.active = false;
                            this.score += 100;
                            App.showHit("HIT!");
                            // FX
                            ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(t.x, t.y, 100, 0, Math.PI*2); ctx.fill();
                        }
                    }

                    if (t.r > 120) t.active = false; // Miss
                });

                this.targets = this.targets.filter(t => t.active);

                // Luvas
                if (pose) {
                    const drawGlove = (kp, color) => {
                        if (kp.score > 0.3) {
                            ctx.fillStyle = color;
                            ctx.beginPath(); ctx.arc(kp.x, kp.y, 30, 0, Math.PI*2); ctx.fill();
                        }
                    };
                    drawGlove(pose.wrists.l, '#00F3FF');
                    drawGlove(pose.wrists.r, '#FF0055');
                }

                return this.score;
            }
        }

        /**
         * =========================================================================
         * APP CONTROL
         * =========================================================================
         */
        const App = {
            game: null,
            loopId: null,

            init: async () => {
                Gfx.init();
                const ready = await Motion.init();
                if (ready) {
                    document.getElementById('screen-loading').classList.add('hidden');
                    document.getElementById('screen-menu').classList.remove('hidden');
                    document.getElementById('screen-menu').classList.add('flex');
                }
            },

            launch: (type) => {
                document.getElementById('screen-menu').classList.remove('flex');
                document.getElementById('screen-menu').classList.add('hidden');
                document.getElementById('screen-hud').classList.remove('hidden');
                document.getElementById('screen-hud').classList.add('flex');

                if (type === 'kart') App.game = new GameKart();
                if (type === 'run') App.game = new GameRun();
                if (type === 'box') App.game = new GameBox();

                App.loop();
            },

            stop: () => {
                cancelAnimationFrame(App.loopId);
                App.game = null;
                document.getElementById('screen-hud').classList.add('hidden');
                document.getElementById('screen-menu').classList.remove('hidden');
                document.getElementById('screen-menu').classList.add('flex');
                Gfx.clear();
            },

            showHit: (txt) => {
                const el = document.getElementById('hit-feedback');
                el.innerText = txt;
                el.style.opacity = 1;
                el.style.transform = "translate(-50%, -50%) scale(1.5)";
                setTimeout(() => {
                    el.style.opacity = 0;
                    el.style.transform = "translate(-50%, -50%) scale(1)";
                }, 300);
            },

            loop: async () => {
                if (!App.game) return;
                const pose = await Motion.getPose();
                if (pose) {
                    const score = App.game.update(pose, Gfx.ctx, Gfx.width, Gfx.height);
                    document.getElementById('hud-score').innerText = score;
                }
                App.loopId = requestAnimationFrame(App.loop);
            }
        };

        window.onload = App.init;

    </script>
</body>
</html>
