<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0f172a">
    <title>thIAguinho Wii: ARCADE</title>
    
    <!-- TENSORFLOW.JS (Core & Models) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <!-- TAILWIND CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- FONTS -->
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@300;700;900&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary: #00F0FF;
            --secondary: #FF003C;
            --accent: #39FF14;
            --bg-dark: #050505;
        }

        body {
            background-color: var(--bg-dark);
            font-family: 'Exo 2', sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            color: white;
            margin: 0;
            width: 100vw; height: 100vh;
        }

        /* LAYOUT & CAMADAS */
        #viewport { position: relative; width: 100%; height: 100%; overflow: hidden; }
        
        #video-feed {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scaleX(-1); /* Espelho Visual CSS */
            min-width: 100%; min-height: 100%;
            width: auto; height: auto;
            object-fit: cover;
            opacity: 0.2; /* Visibilidade sutil do v√≠deo real */
            z-index: 0;
            pointer-events: none;
        }

        #game-canvas { 
            position: absolute; inset: 0; z-index: 10; width: 100%; height: 100%; 
            /* O canvas N√ÉO √© espelhado via CSS, ser√° via Contexto 2D para controle total */
        }

        #ui-layer { 
            position: absolute; inset: 0; z-index: 20; pointer-events: none; 
            padding: env(safe-area-inset-top) 20px 40px 20px;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        .interactive { pointer-events: auto; }

        /* UI ELEMENTS */
        .game-card {
            background: rgba(15, 23, 42, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: 4px solid var(--primary);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            transition: all 0.2s ease-out;
            position: relative; overflow: hidden;
        }
        .game-card:active { transform: scale(0.95); background: rgba(255, 255, 255, 0.1); }
        .card-icon { font-size: 2.5rem; filter: drop-shadow(0 0 8px var(--primary)); }

        .brand-logo { letter-spacing: -1px; text-transform: uppercase; }
        .brand-highlight { color: var(--primary); text-shadow: 0 0 15px var(--primary); }

        /* LOADER */
        .loader {
            width: 48px; height: 48px;
            border: 4px solid #FFF;
            border-bottom-color: var(--primary);
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* HUD STYLES */
        .hud-panel {
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 99px;
            padding: 8px 24px;
            display: flex; flex-direction: column; align-items: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        .hud-value { font-variant-numeric: tabular-nums; letter-spacing: 1px; }

        /* ANIMATIONS */
        @keyframes pulse-border { 0% { border-color: rgba(255,255,255,0.1); } 50% { border-color: var(--primary); } 100% { border-color: rgba(255,255,255,0.1); } }
        .guide-box { animation: pulse-border 2s infinite; border: 2px dashed rgba(255,255,255,0.3); border-radius: 12px; }
        
        #debug-log { font-family: monospace; font-size: 10px; color: #555; text-align: center; margin-top: 10px; }
    </style>
</head>
<body>

    <div id="viewport">
        <!-- V√çDEO FEED (FUNDO) -->
        <video id="video-feed" autoplay muted playsinline></video>
        
        <!-- CANVAS (JOGO + ESQUELETO) -->
        <canvas id="game-canvas"></canvas>

        <!-- UI LAYER -->
        <div id="ui-layer">
            
            <!-- TELA DE LOADING -->
            <div id="screen-load" class="absolute inset-0 bg-slate-900 z-50 flex flex-col items-center justify-center interactive">
                <div class="loader mb-6"></div>
                <h1 class="text-3xl font-black text-white brand-logo">th<span class="brand-highlight">IA</span>guinho</h1>
                <p class="text-slate-400 text-xs font-bold tracking-[0.3em] mt-2">CALIBRANDO SENSORES...</p>
                <div id="debug-log">Inicializando TensorFlow...</div>
            </div>

            <!-- MENU PRINCIPAL -->
            <div id="screen-menu" class="hidden absolute inset-0 bg-slate-900/90 backdrop-blur-md z-40 flex flex-col items-center justify-center interactive p-6">
                <div class="text-center mb-10">
                    <h1 class="text-6xl font-black text-white brand-logo leading-none drop-shadow-2xl italic">
                        thIAguinho<br><span class="brand-highlight">ARCADE</span>
                    </h1>
                    <div class="mt-4 flex justify-center gap-2">
                        <span class="px-2 py-1 bg-white/10 rounded text-[10px] font-bold text-white">AR CORE</span>
                        <span class="px-2 py-1 bg-white/10 rounded text-[10px] font-bold text-white">60 FPS</span>
                    </div>
                </div>

                <div class="grid grid-cols-1 gap-4 w-full max-w-sm">
                    <!-- KART -->
                    <div onclick="App.launch('kart')" class="game-card flex items-center p-4 cursor-pointer hover:bg-white/5">
                        <div class="card-icon mr-4">üèéÔ∏è</div>
                        <div class="flex-1">
                            <h2 class="text-xl font-bold text-white uppercase italic">NEON DRIFT</h2>
                            <p class="text-xs text-slate-400">Dire√ß√£o Real 1:1</p>
                        </div>
                        <div class="text-slate-500 font-bold">GO</div>
                    </div>

                    <!-- RUN -->
                    <div onclick="App.launch('run')" class="game-card flex items-center p-4 cursor-pointer hover:bg-white/5" style="border-left-color: var(--accent);">
                        <div class="card-icon mr-4">üèÉ</div>
                        <div class="flex-1">
                            <h2 class="text-xl font-bold text-white uppercase italic">CYBER RUN</h2>
                            <p class="text-xs text-slate-400">Corrida F√≠sica & Pulo</p>
                        </div>
                        <div class="text-slate-500 font-bold">GO</div>
                    </div>

                    <!-- BOXE -->
                    <div onclick="App.launch('beat')" class="game-card flex items-center p-4 cursor-pointer hover:bg-white/5" style="border-left-color: var(--secondary);">
                        <div class="card-icon mr-4">ü•ä</div>
                        <div class="flex-1">
                            <h2 class="text-xl font-bold text-white uppercase italic">PRO BOXING</h2>
                            <p class="text-xs text-slate-400">Impacto & Ritmo</p>
                        </div>
                        <div class="text-slate-500 font-bold">GO</div>
                    </div>
                </div>
                
                <p class="text-slate-600 text-[10px] mt-8 max-w-xs text-center">
                    Mantenha o celular est√°vel. Afaste-se 1.5m para detec√ß√£o de corpo inteiro.
                </p>
            </div>

            <!-- HUD (IN-GAME) -->
            <div id="screen-hud" class="hidden w-full h-full flex flex-col justify-between pointer-events-none">
                <!-- Top Bar -->
                <div class="flex justify-between items-start w-full">
                    <div class="hud-panel">
                        <span class="text-[9px] text-cyan-400 font-bold uppercase tracking-widest">SCORE</span>
                        <span id="hud-score" class="text-2xl font-black text-white leading-none hud-value">0</span>
                    </div>
                    
                    <button onclick="App.stop()" class="interactive w-10 h-10 rounded-full bg-white/10 backdrop-blur border border-white/20 text-red-400 font-bold flex items-center justify-center active:bg-white/20 transition-all shadow-lg">
                        ‚úï
                    </button>
                </div>
                
                <!-- Feedback Central -->
                <div id="hud-msg" class="absolute inset-0 flex items-center justify-center text-5xl font-black text-white italic drop-shadow-[0_4px_0_rgba(0,0,0,0.8)] opacity-0 transition-opacity duration-150 text-center z-50 pointer-events-none" style="-webkit-text-stroke: 1px black;">
                </div>

                <!-- Bottom Stats -->
                <div class="w-full flex flex-col items-center gap-2">
                    <div id="hud-gauge-container" class="hidden w-64 h-2 bg-gray-800 rounded-full overflow-hidden border border-gray-600">
                        <div id="hud-gauge-fill" class="h-full bg-gradient-to-r from-green-400 to-cyan-400 w-0 transition-all duration-100"></div>
                    </div>
                    <span id="hud-subtext" class="text-xs font-bold text-slate-400 bg-black/50 px-3 py-1 rounded-full uppercase">READY</span>
                </div>
            </div>

        </div>
    </div>

    <script>
        /**
         * =========================================================================
         * 1. MOTION ENGINE (CORE)
         * Respons√°vel por normalizar dados do TensorFlow e corrigir espelhamento.
         * =========================================================================
         */
        const Motion = {
            detector: null,
            video: document.getElementById('video-feed'),
            prevPose: null,
            lastFrameTime: 0,
            smoothing: 0.15, // Fator de suaviza√ß√£o (menor = mais suave, maior = mais r√°pido)

            init: async () => {
                const log = (t) => {
                    const el = document.getElementById('debug-log');
                    if(el) el.innerText = t;
                    console.log(t);
                }
                
                try {
                    await tf.setBackend('webgl');
                    log("Acessando C√¢mera...");
                    
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } },
                        audio: false
                    });
                    Motion.video.srcObject = stream;
                    await new Promise(r => Motion.video.onloadedmetadata = r);
                    Motion.video.play();

                    log("Carregando Rede Neural...");
                    const config = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING };
                    Motion.detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, config);
                    return true;
                } catch (e) {
                    alert("ERRO CR√çTICO: " + e.message);
                    return false;
                }
            },

            // Processamento do Frame
            update: async (width, height) => {
                if (!Motion.detector) return null;
                
                const now = performance.now();
                const dt = Math.min((now - Motion.lastFrameTime) / 1000, 0.1); // Cap DT em 0.1s
                Motion.lastFrameTime = now;

                let poses = null;
                try {
                    poses = await Motion.detector.estimatePoses(Motion.video);
                } catch(e) { return null; }

                if (!poses || poses.length === 0) return null;

                const rawKeypoints = poses[0].keypoints;
                
                // Dimens√µes do v√≠deo fonte
                const vw = Motion.video.videoWidth;
                const vh = Motion.video.videoHeight;
                
                // L√≥gica de "Object-Fit: Cover"
                const scale = Math.max(width / vw, height / vh);
                const ox = (width - (vw * scale)) / 2;
                const oy = (height - (vh * scale)) / 2;

                // CORRE√á√ÉO DEFINITIVA DE ESPELHAMENTO:
                // O v√≠deo CSS tem transform: scaleX(-1), invertendo visualmente.
                // O Canvas vai desenhar em cima.
                // Se desenharmos no X original, ficar√° invertido em rela√ß√£o ao visual.
                // Para alinhar: Canvas X = LarguraTela - (VideoX_Mapeado)
                const mapPoint = (kp) => ({
                    // INVERS√ÉO: Inverte a coordenada X para alinhar com o v√≠deo espelhado
                    x: width - (((vw - kp.x) * scale) + ox), 
                    y: (kp.y * scale) + oy,
                    score: kp.score,
                    name: kp.name
                });

                const rawMapped = rawKeypoints.map(mapPoint);
                const find = n => rawMapped.find(k => k.name === n);

                // Pontos de interesse
                const nose = find('nose');
                const ls = find('left_shoulder');
                const rs = find('right_shoulder');
                const lw = find('left_wrist');
                const rw = find('right_wrist');
                const le = find('left_elbow');
                const re = find('right_elbow');

                // Normaliza√ß√£o Antropom√©trica (Largura dos ombros)
                let bodyWidth = 100; // Valor de fallback
                if (ls.score > 0.3 && rs.score > 0.3) {
                    bodyWidth = Math.hypot(ls.x - rs.x, ls.y - rs.y);
                } else if (Motion.prevPose) {
                    bodyWidth = Motion.prevPose.bodyWidth;
                }

                // CORRE√á√ÉO DE LADOS (ESQ/DIR)
                // No espelho: 
                // Minha m√£o esquerda (f√≠sica) -> aparece na esquerda da tela.
                // O TensorFlow detecta "left_wrist".
                // Mas matematicamente, na tela, o X √© pequeno (esquerda).
                // Ent√£o: Left Wrist na tela = Esquerda F√≠sica.
                // Isso significa que n√£o precisamos inverter os nomes das vari√°veis, apenas confiar na coordenada X da tela.

                const currentPose = {
                    nose, 
                    shoulders: { l: ls, r: rs },
                    wrists: { l: lw, r: rw },
                    elbows: { l: le, r: re },
                    bodyWidth,
                    dt,
                    // Velocidade calculada (pixels/sec)
                    velocity: { l: 0, r: 0 }
                };

                // C√°lculo de F√≠sica e Suaviza√ß√£o
                if (Motion.prevPose) {
                    // C√°lculo de velocidade bruta antes de suavizar
                    const distL = Math.hypot(currentPose.wrists.l.x - Motion.prevPose.rawWrists.l.x, currentPose.wrists.l.y - Motion.prevPose.rawWrists.l.y);
                    const distR = Math.hypot(currentPose.wrists.r.x - Motion.prevPose.rawWrists.r.x, currentPose.wrists.r.y - Motion.prevPose.rawWrists.r.y);
                    
                    // Velocidade normalizada pelo tamanho do corpo
                    currentPose.velocity.l = (distL / dt) / bodyWidth;
                    currentPose.velocity.r = (distR / dt) / bodyWidth;

                    // Suaviza√ß√£o EMA (Exponential Moving Average)
                    const lerp = (a, b, t) => a + (b - a) * t;
                    const smoothPoint = (curr, prev) => {
                        curr.x = lerp(prev.x, curr.x, Motion.smoothing);
                        curr.y = lerp(prev.y, curr.y, Motion.smoothing);
                    };

                    smoothPoint(currentPose.nose, Motion.prevPose.nose);
                    smoothPoint(currentPose.shoulders.l, Motion.prevPose.shoulders.l);
                    smoothPoint(currentPose.shoulders.r, Motion.prevPose.shoulders.r);
                    smoothPoint(currentPose.wrists.l, Motion.prevPose.wrists.l);
                    smoothPoint(currentPose.wrists.r, Motion.prevPose.wrists.r);
                    smoothPoint(currentPose.elbows.l, Motion.prevPose.elbows.l);
                    smoothPoint(currentPose.elbows.r, Motion.prevPose.elbows.r);
                }

                // Armazena dados para o pr√≥ximo frame
                currentPose.rawWrists = { l: {x: lw.x, y: lw.y}, r: {x: rw.x, y: rw.y} };
                Motion.prevPose = currentPose;

                return currentPose;
            }
        };

        /**
         * =========================================================================
         * 2. GRAPHICS ENGINE (RENDERIZA√á√ÉO)
         * =========================================================================
         */
        const Gfx = {
            canvas: document.getElementById('game-canvas'),
            ctx: null,
            width: 0, height: 0,

            init: () => {
                Gfx.ctx = Gfx.canvas.getContext('2d', { alpha: true });
                window.addEventListener('resize', Gfx.resize);
                Gfx.resize();
            },

            resize: () => {
                const dpr = window.devicePixelRatio || 1;
                Gfx.width = window.innerWidth;
                Gfx.height = window.innerHeight;
                Gfx.canvas.width = Gfx.width * dpr;
                Gfx.canvas.height = Gfx.height * dpr;
                Gfx.ctx.scale(dpr, dpr);
            },

            clear: () => Gfx.ctx.clearRect(0, 0, Gfx.width, Gfx.height),

            // RENDERIZADOR DE ESQUELETO (Personagem Principal)
            drawSkeleton: (pose, color = '#00F0FF', thickness = 6) => {
                if (!pose) return;
                const ctx = Gfx.ctx;
                
                ctx.save();
                ctx.strokeStyle = color;
                ctx.lineWidth = thickness;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Glow Effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;

                const drawLine = (p1, p2) => {
                    if (p1.score > 0.3 && p2.score > 0.3) {
                        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                    }
                };

                // Conex√µes
                drawLine(pose.shoulders.l, pose.shoulders.r); // Ombros
                drawLine(pose.shoulders.l, pose.elbows.l);    // Bra√ßo Esq
                drawLine(pose.elbows.l, pose.wrists.l);
                drawLine(pose.shoulders.r, pose.elbows.r);    // Bra√ßo Dir
                drawLine(pose.elbows.r, pose.wrists.r);

                // Cabe√ßa (Nariz)
                if (pose.nose.score > 0.3) {
                    ctx.beginPath();
                    ctx.fillStyle = '#fff';
                    ctx.arc(pose.nose.x, pose.nose.y, thickness * 1.5, 0, Math.PI*2);
                    ctx.fill();
                }

                // Juntas
                ctx.fillStyle = color;
                [pose.shoulders.l, pose.shoulders.r, pose.elbows.l, pose.elbows.r, pose.wrists.l, pose.wrists.r].forEach(p => {
                    if (p.score > 0.3) {
                        ctx.beginPath(); ctx.arc(p.x, p.y, thickness/2, 0, Math.PI*2); ctx.fill();
                    }
                });

                ctx.restore();
            }
        };

        /**
         * =========================================================================
         * JOGO 1: NEON DRIFT (KART)
         * =========================================================================
         */
        class GameKart {
            constructor() {
                this.speed = 0;
                this.steering = 0;
                this.carX = 0;
                this.curve = 0;
                this.score = 0;
                this.obstacles = [];
                this.handsOnWheel = false;
                
                document.getElementById('hud-gauge-container').classList.remove('hidden');
                document.getElementById('hud-subtext').innerText = "SEGURE O VOLANTE";
                App.msg("START!", "#00F0FF");
            }

            update(pose, ctx, w, h) {
                // 1. C√ÅLCULO DE DIRE√á√ÉO (VETOR PULSO A PULSO)
                this.handsOnWheel = false;
                let targetAngle = 0;

                // Para o volante funcionar corretamente no espelho:
                // M√£o Esquerda na Tela (F√≠sica Esq) = wrist.l
                // M√£o Direita na Tela (F√≠sica Dir) = wrist.r
                // √Çngulo positivo = Virar para a Direita (M√£o direita desce, esquerda sobe)
                
                if (pose.wrists.l.score > 0.4 && pose.wrists.r.score > 0.4) {
                    // Diferen√ßa de altura
                    const dy = pose.wrists.r.y - pose.wrists.l.y;
                    const dx = pose.wrists.r.x - pose.wrists.l.x;
                    const rawAngle = Math.atan2(dy, dx);

                    // Compensa√ß√£o de inclina√ß√£o do corpo
                    const sDy = pose.shoulders.r.y - pose.shoulders.l.y;
                    const sDx = pose.shoulders.r.x - pose.shoulders.l.x;
                    const bodyAngle = Math.atan2(sDy, sDx);

                    let steeringAngle = rawAngle - bodyAngle;

                    // Ajuste de sentido: No espelho, se eu giro para a direita (hor√°rio), 
                    // minha m√£o direita (tela direita) desce. DY √© positivo. Angle positivo.
                    // Isso est√° correto para Math.atan2.

                    // Limites e Deadzone
                    if (Math.abs(steeringAngle) < 0.1) steeringAngle = 0; 
                    steeringAngle = Math.max(-1.0, Math.min(1.0, steeringAngle));

                    // Altura das m√£os (Volante)
                    const handsY = (pose.wrists.l.y + pose.wrists.r.y) / 2;
                    if (handsY < h * 0.8) {
                        this.handsOnWheel = true;
                        targetAngle = steeringAngle;
                        this.speed = Math.min(120, this.speed + 60 * pose.dt);
                    }
                }

                if (!this.handsOnWheel) {
                    this.speed *= 0.95; 
                    targetAngle = 0; 
                }

                this.steering += (targetAngle - this.steering) * 5 * pose.dt;

                // F√≠sica do Carro
                this.curve = Math.sin(Date.now() / 2000) * 0.5; 
                const turnForce = this.steering * 3.5;
                const centrifugal = this.curve * (this.speed / 100);
                
                this.carX += (turnForce - centrifugal) * pose.dt;
                
                if (this.carX < -1.5) { this.carX = -1.5; this.speed *= 0.9; }
                if (this.carX > 1.5) { this.carX = 1.5; this.speed *= 0.9; }

                this.score += Math.floor(this.speed * pose.dt);

                // Spawn Obst√°culos
                if (Math.random() < 0.02 && this.speed > 30) {
                    this.obstacles.push({ x: (Math.random()-0.5)*2.5, z: 0 });
                }

                // --- RENDERIZA√á√ÉO ---
                ctx.clearRect(0,0,w,h);
                
                // Fundo & Pista
                const horizon = h * 0.4;
                const grad = ctx.createLinearGradient(0,0,0,h);
                grad.addColorStop(0, '#020617'); grad.addColorStop(1, '#1e293b');
                ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);

                // Pista
                ctx.fillStyle = '#334155';
                ctx.beginPath();
                const centerTop = w/2 + (this.curve * 200);
                const centerBot = w/2 + (this.carX * -300); 
                
                ctx.moveTo(centerTop - 10, horizon);
                ctx.lineTo(centerTop + 10, horizon);
                ctx.lineTo(centerBot + w, h);
                ctx.lineTo(centerBot - w, h);
                ctx.fill();

                // Obst√°culos
                this.obstacles.forEach((obs, i) => {
                    obs.z += (this.speed * 0.002) * pose.dt * 60;
                    if (obs.z > 1.2) { this.obstacles.splice(i,1); return; }

                    const scale = obs.z * obs.z;
                    const drawY = horizon + (obs.z * (h - horizon));
                    const roadX = centerTop + (centerBot - centerTop) * obs.z;
                    const drawX = roadX + (obs.x * w * 0.5 * obs.z);
                    const size = 40 + (100 * scale);

                    ctx.fillStyle = '#F43F5E';
                    ctx.fillRect(drawX - size/2, drawY - size, size, size);

                    // Colis√£o
                    if (obs.z > 0.85 && obs.z < 0.95 && Math.abs(drawX - w/2) < 80) {
                        this.speed = 10;
                        App.msg("CRASH!", "#F43F5E");
                        ctx.fillStyle = 'white'; ctx.fillRect(0,0,w,h);
                    }
                });

                // Carro
                const cx = w/2; const cy = h - 120;
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(this.steering * 0.4); 
                
                ctx.fillStyle = '#00F0FF';
                ctx.beginPath(); ctx.roundRect(-60, -30, 120, 60, 10); ctx.fill();
                ctx.fillStyle = '#ef4444'; 
                ctx.beginPath(); ctx.arc(-40, 0, 12, 0, Math.PI*2); ctx.fill(); 
                ctx.beginPath(); ctx.arc(40, 0, 12, 0, Math.PI*2); ctx.fill();  
                ctx.restore();

                // Volante Virtual
                const wheelX = w/2; const wheelY = 150;
                ctx.save();
                ctx.translate(wheelX, wheelY);
                ctx.rotate(this.steering);
                ctx.beginPath(); ctx.arc(0,0, 60, 0, Math.PI*2);
                ctx.lineWidth = 10; 
                ctx.strokeStyle = this.handsOnWheel ? 'rgba(0, 240, 255, 0.8)' : 'rgba(255,255,255,0.2)';
                ctx.stroke();
                // Raios
                ctx.beginPath(); ctx.moveTo(-60,0); ctx.lineTo(60,0); ctx.stroke();
                ctx.restore();

                if (!this.handsOnWheel) {
                    ctx.fillStyle = 'white'; ctx.font = "bold 14px sans-serif"; ctx.textAlign = "center";
                    ctx.fillText("SEGURE O VOLANTE AQUI", wheelX, wheelY + 90);
                }

                Gfx.drawSkeleton(pose, this.handsOnWheel ? '#00F0FF' : '#555');

                document.getElementById('hud-gauge-fill').style.width = (this.speed/120)*100 + '%';
                return this.score;
            }
        }

        /**
         * =========================================================================
         * JOGO 2: CYBER RUN (CORRIDA DE RUA F√çSICA)
         * =========================================================================
         */
        class GameRun {
            constructor() {
                this.score = 0;
                this.speed = 0;
                this.playerX = 0; 
                this.playerY = 0; 
                this.jumpVel = 0;
                this.runEnergy = 0;
                this.obstacles = [];
                this.lastShoulderY = 0;
                this.distance = 0;

                document.getElementById('hud-gauge-container').classList.remove('hidden');
                document.getElementById('hud-subtext').innerText = "CORRA PARA MOVER";
                App.msg("RUN!", "#39FF14");
            }

            update(pose, ctx, w, h) {
                // 1. INPUT ANAL√ìGICO
                if (pose.shoulders.l.score > 0.4 && pose.shoulders.r.score > 0.4) {
                    const midX = pose.center.x; // J√° espelhado corretamente em Motion.update
                    const midY = pose.center.y;

                    // CONTROLE LATERAL 1:1
                    const screenCenter = w / 2;
                    const diffX = midX - screenCenter;
                    
                    // Como o X j√° est√° invertido no Motion.update para ser visualmente correto:
                    // Se eu vou para a Direita da tela, X aumenta. (X > Center). Diff > 0. Player vai pra direita.
                    // Isso est√° correto.
                    this.playerX = diffX / (pose.bodyWidth * 1.5); 
                    this.playerX = Math.max(-1, Math.min(1, this.playerX));

                    // DETEC√á√ÉO DE CORRIDA
                    if (!this.lastShoulderY) this.lastShoulderY = midY;
                    const deltaY = Math.abs(midY - this.lastShoulderY);
                    this.lastShoulderY = midY;

                    const activity = deltaY / pose.bodyWidth;
                    
                    if (activity > 0.04) { 
                        this.runEnergy = Math.min(1, this.runEnergy + 2.0 * pose.dt);
                    } else {
                        this.runEnergy = Math.max(0, this.runEnergy - 1.5 * pose.dt);
                    }
                    this.speed = this.runEnergy * 60; 

                    // DETEC√á√ÉO DE PULO
                    // Se subiu r√°pido? (Y diminui subindo)
                    // No Motion.update, Y √© raw pixel value. 0 = topo.
                    // Subir = Y diminui.
                    // Velocidade vertical (antiga - nova) > threshold positivo
                    const jumpSpeed = (this.lastShoulderY - midY); // Positivo se subiu
                    
                    if (this.playerY === 0 && jumpSpeed > (pose.bodyWidth * 0.1)) {
                        this.jumpVel = 18;
                        this.playerY = 1;
                        App.msg("PULO!", "#39FF14");
                    }
                }

                // F√çSICA
                this.distance += this.speed * pose.dt;
                this.score = Math.floor(this.distance * 10);

                // Gravidade
                if (this.playerY > 0) {
                    this.playerY += this.jumpVel * pose.dt * 60 * 0.05; 
                    this.jumpVel -= 50 * pose.dt; 
                    if (this.playerY <= 0) { this.playerY = 0; this.jumpVel = 0; }
                }

                // Obst√°culos
                if (Math.random() < 0.02 && this.speed > 5) {
                    this.obstacles.push({ x: (Math.random()-0.5)*1.5, z: 0, type: Math.random()>0.5 ? 'low':'high' });
                }

                // RENDER
                ctx.clearRect(0,0,w,h);
                
                const horizon = h * 0.4;
                ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,w,h);
                
                ctx.fillStyle = '#1e293b';
                ctx.beginPath(); ctx.moveTo(w/2, horizon); ctx.lineTo(w*2, h); ctx.lineTo(-w, h); ctx.fill();

                // Grid
                const gridOffset = (this.distance * 50) % 50;
                ctx.strokeStyle = '#39FF14'; ctx.lineWidth = 2; ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.moveTo(w/2, horizon); ctx.lineTo(w/2, h);
                ctx.moveTo(w/2, horizon); ctx.lineTo(w*0.8, h);
                ctx.moveTo(w/2, horizon); ctx.lineTo(w*0.2, h);
                for(let i=0; i<10; i++) {
                    let y = h - (i*40) + gridOffset;
                    if (y > horizon && y < h) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
                }
                ctx.stroke();
                ctx.globalAlpha = 1.0;

                // Obst√°culos
                this.obstacles.forEach((obs, i) => {
                    obs.z += (this.speed * 0.005 + 0.01) * 60 * pose.dt;
                    if (obs.z > 1.2) { this.obstacles.splice(i,1); return; }

                    const scale = obs.z;
                    const roadW = w * 2 * scale;
                    const drawX = (w/2) + (obs.x * roadW * 0.5);
                    const drawY = horizon + (obs.z * (h - horizon));
                    const size = 50 * scale;

                    ctx.fillStyle = obs.type === 'low' ? '#eab308' : '#ef4444';
                    const yOffset = obs.type === 'high' ? size * 1.5 : 0;
                    ctx.fillRect(drawX - size/2, drawY - size - yOffset, size, size);

                    // Colis√£o
                    if (obs.z > 0.85 && obs.z < 0.95) {
                        const dist = Math.abs(drawX - ((w/2) + (this.playerX * w * 0.4)));
                        const hitLow = obs.type === 'low' && this.playerY < 0.5; 
                        const hitHigh = obs.type === 'high' && this.playerY > 0.5; 
                        
                        if (dist < size && hitLow) {
                            this.speed = 0; this.runEnergy = 0;
                            App.msg("BATEU!", "#ef4444");
                            ctx.fillStyle = 'white'; ctx.fillRect(0,0,w,h);
                            this.obstacles.splice(i,1);
                        }
                    }
                });

                // AVATAR
                ctx.save();
                const jumpPx = this.playerY * -150;
                ctx.translate(0, jumpPx);
                Gfx.drawSkeleton(pose, '#39FF14');
                ctx.restore();

                document.getElementById('hud-gauge-fill').style.width = (this.speed/60)*100 + '%';
                return this.score;
            }
        }

        /**
         * =========================================================================
         * JOGO 3: PRO BOXING (F√çSICA E RITMO)
         * =========================================================================
         */
        class GameBox {
            constructor() {
                this.score = 0;
                this.combo = 0;
                this.targets = [];
                this.timer = 0;
                this.beatInterval = 1.0; 
                
                document.getElementById('hud-gauge-container').classList.add('hidden');
                document.getElementById('hud-subtext').innerText = "SOQUE OS ALVOS";
                App.msg("BOXE!", "#FF003C");
            }

            update(pose, ctx, w, h) {
                // SPAWN
                this.timer += pose.dt;
                if (this.timer > this.beatInterval) {
                    this.timer = 0;
                    const side = Math.random() > 0.5 ? 'left' : 'right';
                    this.targets.push({
                        x: side === 'left' ? w * 0.25 : w * 0.75,
                        y: Math.random() > 0.5 ? h * 0.3 : h * 0.6,
                        radius: 10,
                        active: true,
                        side: side,
                        color: side === 'left' ? '#00F0FF' : '#FF003C',
                        hit: false
                    });
                    this.beatInterval = Math.max(0.5, this.beatInterval * 0.98); 
                }

                // RENDER & COLIS√ÉO
                ctx.clearRect(0,0,w,h);
                
                Gfx.drawSkeleton(pose, '#555', 4);

                this.targets.forEach(t => {
                    if (!t.active) return;
                    
                    t.radius += 100 * pose.dt;
                    const hitZone = 70; 

                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.radius, 0, Math.PI*2);
                    ctx.fillStyle = t.color + '44';
                    ctx.fill();
                    ctx.lineWidth = 4;
                    ctx.strokeStyle = Math.abs(t.radius - hitZone) < 15 ? '#FFF' : t.color;
                    ctx.stroke();

                    // Detectar Hit
                    if (!t.hit && t.radius > 40) {
                        const hand = t.side === 'left' ? pose.wrists.l : pose.wrists.r;
                        const velocity = t.side === 'left' ? pose.velocity.l : pose.velocity.r;
                        
                        const dist = Math.hypot(hand.x - t.x, hand.y - t.y);
                        
                        // Hitbox generosa mas exige velocidade
                        if (dist < t.radius + 30) {
                            if (velocity > 2.0) { // Velocidade m√≠nima
                                t.hit = true;
                                t.active = false;
                                this.combo++;
                                
                                const isStrong = velocity > 5.0;
                                const points = isStrong ? 300 : 100;
                                this.score += points + (this.combo * 10);
                                
                                App.msg(isStrong ? "SMASH!" : "HIT", t.color);
                                
                                // FX
                                ctx.fillStyle = 'white';
                                ctx.beginPath(); ctx.arc(t.x, t.y, 100, 0, Math.PI*2); ctx.fill();
                            }
                        }
                    }

                    if (t.radius > 110) {
                        t.active = false;
                        this.combo = 0;
                        App.msg("MISS", "#555");
                    }
                });

                this.targets = this.targets.filter(t => t.active);

                const drawGlove = (kp, color, vel) => {
                    if (kp.score > 0.3) {
                        const size = 30 + Math.min(20, vel * 3);
                        ctx.shadowBlur = 20; ctx.shadowColor = color;
                        ctx.fillStyle = color;
                        ctx.beginPath(); ctx.arc(kp.x, kp.y, size, 0, Math.PI*2); ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                };
                drawGlove(pose.wrists.l, '#00F0FF', pose.velocity.l);
                drawGlove(pose.wrists.r, '#FF003C', pose.velocity.r);

                return this.score;
            }
        }

        /**
         * =========================================================================
         * 3. APP CONTROLLER
         * =========================================================================
         */
        const App = {
            game: null,
            loopId: null,

            init: async () => {
                Gfx.init();
                const ready = await Motion.init();
                if (ready) {
                    document.getElementById('screen-load').classList.add('hidden');
                    document.getElementById('screen-menu').classList.remove('hidden');
                    document.getElementById('screen-menu').classList.add('flex');
                }
            },

            launch: (type) => {
                document.getElementById('screen-menu').classList.remove('flex');
                document.getElementById('screen-menu').classList.add('hidden');
                document.getElementById('screen-hud').classList.remove('hidden');
                document.getElementById('screen-hud').classList.add('flex');

                if (type === 'kart') App.game = new GameKart();
                if (type === 'run') App.game = new GameRun();
                if (type === 'beat') App.game = new GameBox();

                App.loop();
            },

            stop: () => {
                cancelAnimationFrame(App.loopId);
                App.game = null;
                document.getElementById('screen-hud').classList.add('hidden');
                document.getElementById('screen-menu').classList.remove('hidden');
                document.getElementById('screen-menu').classList.add('flex');
                Gfx.clear();
            },

            msg: (text, color='#FFF') => {
                const el = document.getElementById('hud-msg');
                el.innerText = text;
                el.style.color = color;
                el.style.opacity = 1;
                el.style.transform = "scale(1.2) skewX(-10deg)";
                setTimeout(() => {
                    el.style.opacity = 0;
                    el.style.transform = "scale(1)";
                }, 600);
            },

            loop: async () => {
                if (!App.game) return;

                const pose = await Motion.update(Gfx.width, Gfx.height);
                if (pose) {
                    const score = App.game.update(pose, Gfx.ctx, Gfx.width, Gfx.height);
                    document.getElementById('hud-score').innerText = score;
                }

                App.loopId = requestAnimationFrame(App.loop);
            }
        };

        window.onload = App.init;

    </script>
</body>
</html>
