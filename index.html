<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>thIAguinho Wii: GOLD EDITION</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Russo+One&display=swap');

        /* --- ENGINE CORE --- */
        body {
            background-color: #111;
            margin: 0; overflow: hidden;
            font-family: 'Russo One', sans-serif;
            touch-action: none; user-select: none;
            -webkit-user-select: none;
        }

        #stage { position: relative; width: 100vw; height: 100vh; background: #000; }

        /* V√çDEO (Espelho M√°gico) */
        #webcam {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Espelha o v√≠deo */
            opacity: 0.2; /* Fica sutil no fundo */
            filter: grayscale(100%) contrast(1.2);
            z-index: 0;
        }
        #video-source { display: none; }

        /* CANVAS (Gr√°ficos 60 FPS) */
        #game-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
        }

        /* UI (Interfaces) */
        .layer {
            position: absolute; inset: 0;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 20; transition: opacity 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; display: none !important; }
        
        /* ESTILO NINTENDO */
        .pixel-font { font-family: 'Press Start 2P', cursive; }
        
        .n-btn {
            background: linear-gradient(180deg, #00d2ff 0%, #3a7bd5 100%);
            border: 4px solid #fff;
            box-shadow: 0 6px 0 #005cbf, 0 10px 10px rgba(0,0,0,0.5);
            color: white;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.2);
            transition: transform 0.1s;
        }
        .n-btn:active { transform: translateY(6px); box-shadow: 0 0 0 #005cbf; }

        .card {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }
        .card:hover { border-color: #00ffff; background: rgba(0,255,255,0.1); transform: scale(1.05); }

        /* HUD */
        .hud-panel {
            background: rgba(0,0,0,0.7);
            border: 2px solid #fff;
            border-radius: 12px;
            padding: 8px 16px;
        }
    </style>
</head>
<body>

<div id="stage">
    <video id="video-source" playsinline></video>
    <video id="webcam" autoplay muted playsinline></video>
    <canvas id="game-canvas"></canvas>

    <div id="screen-boot" class="layer bg-black">
        <h1 class="text-4xl md:text-6xl text-white mb-2 text-center pixel-font text-cyan-400 leading-tight">
            Wii<br><span class="text-white text-2xl">MOTION ENGINE</span>
        </h1>
        <p class="text-gray-500 text-xs mb-12 font-mono">V 5.0 GOLD MASTER</p>
        
        <button onclick="Engine.boot()" class="n-btn px-8 py-4 rounded-full text-xl font-bold uppercase tracking-widest animate-pulse">
            Tocar para Iniciar
        </button>
        <div id="boot-log" class="mt-8 text-cyan-600 font-mono text-xs">Sistema em espera...</div>
    </div>

    <div id="screen-loading" class="layer bg-black/90 hidden">
        <div class="w-16 h-16 border-4 border-white border-t-transparent rounded-full animate-spin mb-4"></div>
        <div class="text-white pixel-font text-xs">CALIBRANDO SENSORES...</div>
    </div>

    <div id="screen-menu" class="layer bg-black/80 hidden overflow-y-auto">
        <h2 class="text-3xl text-white mb-10 pixel-font text-center drop-shadow-md">SELECT GAME</h2>
        
        <div class="grid gap-6 w-full max-w-sm px-6 pb-10">
            <button onclick="Engine.launch('kart')" class="card p-4 rounded-xl flex items-center gap-4 group text-left">
                <div class="text-4xl">üèéÔ∏è</div>
                <div>
                    <h3 class="text-lg text-white font-bold">SUPER KART GP</h3>
                    <p class="text-xs text-gray-400">Gire as m√£os para dirigir.</p>
                </div>
            </button>

            <button onclick="Engine.launch('run')" class="card p-4 rounded-xl flex items-center gap-4 group text-left">
                <div class="text-4xl">üèÉ</div>
                <div>
                    <h3 class="text-lg text-white font-bold">TEMPLE RUNNER</h3>
                    <p class="text-xs text-gray-400">Pule (nariz sobe) e desvie.</p>
                </div>
            </button>

            <button onclick="Engine.launch('box')" class="card p-4 rounded-xl flex items-center gap-4 group text-left">
                <div class="text-4xl">ü•ä</div>
                <div>
                    <h3 class="text-lg text-white font-bold">PUNCH-OUT AR</h3>
                    <p class="text-xs text-gray-400">Soque o rob√¥!</p>
                </div>
            </button>
        </div>
        
        <div class="fixed bottom-4 text-gray-600 text-[10px] font-mono">thIAguinho Solu√ß√µes &copy; 2026</div>
    </div>

    <div id="screen-hud" class="layer hidden justify-between p-4 pointer-events-none !items-start">
        <div class="w-full flex justify-between">
            <div class="hud-panel">
                <div class="text-[10px] text-cyan-400 font-bold">SCORE</div>
                <div id="score-val" class="text-2xl text-white font-mono">0000</div>
            </div>
            
            <button onclick="Engine.quit()" class="pointer-events-auto bg-red-600 text-white w-10 h-10 rounded-full font-bold border-2 border-white shadow-lg">X</button>
        </div>

        <div id="msg-area" class="absolute top-1/3 w-full text-center"></div>

        <div id="hp-bar-container" class="absolute bottom-10 left-1/2 -translate-x-1/2 w-64 h-6 bg-gray-800 border-2 border-white rounded-full hidden overflow-hidden">
            <div id="hp-bar" class="w-full h-full bg-green-500 transition-all duration-200"></div>
        </div>
    </div>

    <div id="screen-over" class="layer bg-red-900/95 hidden pointer-events-auto">
        <h1 class="text-4xl text-white mb-4 pixel-font">GAME OVER</h1>
        <div class="text-6xl text-yellow-400 font-mono font-bold mb-8" id="final-score">0</div>
        <button onclick="Engine.menu()" class="n-btn px-8 py-3 rounded-full text-lg font-bold">VOLTAR</button>
    </div>
</div>

<script>
    /**
     * ==========================================
     * üîä AUDIO (Sintetizador Retro)
     * ==========================================
     */
    const Sfx = {
        ctx: null,
        init: () => { window.AudioContext = window.AudioContext || window.webkitAudioContext; Sfx.ctx = new AudioContext(); },
        play: (freq, type, dur) => {
            if(!Sfx.ctx) return;
            const o = Sfx.ctx.createOscillator(); const g = Sfx.ctx.createGain();
            o.type=type; o.frequency.value=freq;
            g.gain.setValueAtTime(0.1, Sfx.ctx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, Sfx.ctx.currentTime+dur);
            o.connect(g); g.connect(Sfx.ctx.destination);
            o.start(); o.stop(Sfx.ctx.currentTime+dur);
        },
        coin: () => { Sfx.play(1200, 'square', 0.1); setTimeout(()=>Sfx.play(1600,'square',0.1), 100); },
        hit: () => { Sfx.play(150, 'sawtooth', 0.2); },
        jump: () => { Sfx.play(400, 'sine', 0.3); },
        engine: (spd) => { /* Placeholder para som de motor */ }
    };

    /**
     * ==========================================
     * üé® GRAPHICS (Sprites & Pseudo-3D)
     * ==========================================
     */
    const Gfx = {
        // Renderiza Estrada "Mode 7"
        drawRoad: (ctx, w, h, pos, curve) => {
            const hor = h * 0.4;
            // C√©u
            let grad = ctx.createLinearGradient(0,0,0,hor);
            grad.addColorStop(0,'#001'); grad.addColorStop(1,'#800');
            ctx.fillStyle=grad; ctx.fillRect(0,0,w,hor);
            
            // Ch√£o
            ctx.fillStyle='#2c3e50'; ctx.fillRect(0,hor,w,h-hor);

            // Listras (Efeito Velocidade)
            const cx = w/2;
            for(let i=0; i<20; i++) {
                let z = i + (pos%1); // Profundidade
                let scale = 1/z;
                let y = h - (scale * (h-hor) * 4);
                if(y < hor) continue;
                
                let rw = w * 1.5 * scale; // Largura da estrada
                let curveX = Math.pow(i, 2) * curve * (w/100);

                // Zebra
                ctx.fillStyle = (Math.floor(z + pos)%2===0) ? '#ecf0f1' : '#e74c3c';
                ctx.fillRect(cx - rw/2 + curveX - (rw*0.1), y, rw*1.2, 10);

                // Asfalto
                ctx.fillStyle = (Math.floor(z + pos)%2===0) ? '#95a5a6' : '#7f8c8d';
                ctx.fillRect(cx - rw/2 + curveX, y, rw, 10);
            }
        },

        drawKart: (ctx, x, y, steer) => {
            ctx.save(); ctx.translate(x, y); 
            ctx.rotate(steer * 0.5); ctx.scale(2,2);
            // Sombra
            ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.ellipse(0,5,20,8,0,0,Math.PI*2); ctx.fill();
            // Carro
            ctx.fillStyle='#e74c3c'; 
            ctx.beginPath(); ctx.moveTo(-15,5); ctx.lineTo(-12,-8); ctx.lineTo(12,-8); ctx.lineTo(15,5); ctx.fill();
            // Rodas
            ctx.fillStyle='#222'; ctx.fillRect(-18,2,6,6); ctx.fillRect(12,2,6,6);
            // Piloto
            ctx.fillStyle='#f1c40f'; ctx.beginPath(); ctx.arc(0,-8,6,0,Math.PI*2); ctx.fill();
            ctx.restore();
        },

        drawRunner: (ctx, x, y, frame, jumping) => {
            ctx.save(); ctx.translate(x, y); ctx.scale(2.5, 2.5);
            ctx.strokeStyle='#2ecc71'; ctx.lineWidth=3; ctx.lineCap='round';
            
            let s = Math.sin(frame*0.5)*8;
            if(jumping) s = -5; // Perna esticada no pulo

            // Tronco
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-15); ctx.stroke();
            // Pernas
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-5+s, 15); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(5-s, 15); ctx.stroke();
            // Bra√ßos
            ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(-8-s, -5); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(8+s, -5); ctx.stroke();
            // Cabe√ßa
            ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,-20,4,0,Math.PI*2); ctx.fill();
            ctx.restore();
        },

        drawRobot: (ctx, w, h, hitFrame) => {
            const cx = w/2; const cy = h/2;
            let shake = (hitFrame > 0) ? (Math.random()-0.5)*20 : 0;
            
            ctx.save(); ctx.translate(cx + shake, cy + shake);
            
            // Corpo
            ctx.fillStyle = (hitFrame > 0) ? '#fff' : '#34495e';
            ctx.fillRect(-60, -80, 120, 160);
            
            // Olhos
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath(); ctx.arc(-30, -40, 15, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(30, -40, 15, 0, Math.PI*2); ctx.fill();
            
            // HP Bar desenhada no peito
            ctx.fillStyle = '#000'; ctx.fillRect(-40, 20, 80, 10);
            ctx.fillStyle = '#f1c40f'; ctx.fillRect(-38, 22, 76, 6);
            
            ctx.restore();
        }
    };

    /**
     * ==========================================
     * üß† ENGINE (L√≥gica Central)
     * ==========================================
     */
    const Engine = {
        video: null, canvas: null, ctx: null, detector: null,
        active: false, mode: null, loopId: null,
        
        boot: async () => {
            const status = document.getElementById('boot-log');
            status.innerText = "Acessando C√¢mera...";
            Sfx.init();

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: {ideal: 640}, height: {ideal: 480} }, 
                    audio: false
                });
                
                Engine.video = document.getElementById('video-source');
                Engine.video.srcObject = stream;
                document.getElementById('webcam').srcObject = stream;
                await new Promise(r => Engine.video.onloadedmetadata = r);
                Engine.video.play(); document.getElementById('webcam').play();

                document.getElementById('screen-boot').classList.add('hidden');
                document.getElementById('screen-loading').classList.remove('hidden');

                await tf.setBackend('webgl');
                Engine.detector = await poseDetection.createDetector(
                    poseDetection.SupportedModels.MoveNet,
                    { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
                );

                Engine.canvas = document.getElementById('game-canvas');
                Engine.ctx = Engine.canvas.getContext('2d');
                
                document.getElementById('screen-loading').classList.add('hidden');
                Engine.menu();

            } catch(e) {
                status.innerText = "ERRO: " + e.message;
            }
        },

        menu: () => {
            document.getElementById('screen-menu').classList.remove('hidden');
            document.getElementById('screen-hud').classList.add('hidden');
            document.getElementById('screen-over').classList.add('hidden');
        },

        launch: (m) => {
            Engine.mode = m;
            Engine.active = true;
            document.getElementById('screen-menu').classList.add('hidden');
            document.getElementById('screen-hud').classList.remove('hidden');
            
            // Init Game Logic
            if(m==='kart') Kart.init();
            if(m==='run') Runner.init();
            if(m==='box') Box.init();

            // UI Toggle
            const hp = document.getElementById('hp-bar-container');
            if(m==='box') hp.classList.remove('hidden'); else hp.classList.add('hidden');

            Engine.loop();
        },

        quit: () => {
            Engine.active = false;
            cancelAnimationFrame(Engine.loopId);
            Engine.menu();
        },

        loop: async () => {
            if(!Engine.active) return;

            // Resize
            if(Engine.canvas.width !== window.innerWidth) {
                Engine.canvas.width = window.innerWidth;
                Engine.canvas.height = window.innerHeight;
            }

            const poses = await Engine.detector.estimatePoses(Engine.video, {flipHorizontal: false});
            const pose = poses.length > 0 ? poses[0] : null;

            const ctx = Engine.ctx;
            const w = Engine.canvas.width;
            const h = Engine.canvas.height;
            let score = 0;

            if(Engine.mode==='kart') score = Kart.update(ctx, w, h, pose);
            if(Engine.mode==='run') score = Runner.update(ctx, w, h, pose);
            if(Engine.mode==='box') score = Box.update(ctx, w, h, pose);

            document.getElementById('score-val').innerText = score;
            Engine.loopId = requestAnimationFrame(Engine.loop);
        },

        gameOver: (score) => {
            Engine.active = false;
            cancelAnimationFrame(Engine.loopId);
            document.getElementById('final-score').innerText = score;
            document.getElementById('screen-hud').classList.add('hidden');
            document.getElementById('screen-over').classList.remove('hidden');
        },

        msg: (txt) => {
            const el = document.getElementById('msg-area');
            el.innerHTML = `<h1 class="text-4xl text-yellow-400 pixel-font drop-shadow-md animate-bounce">${txt}</h1>`;
            setTimeout(()=>el.innerHTML='', 1500);
        }
    };

    /**
     * ==========================================
     * üèéÔ∏è JOGO 1: SUPER KART GP
     * ==========================================
     */
    const Kart = {
        pos: 0, speed: 0, playerX: 0, steer: 0, curve: 0,
        init: () => { Kart.pos=0; Kart.speed=0; Kart.playerX=0; Engine.msg("START!"); },
        update: (ctx, w, h, pose) => {
            const k = Kart;
            const cx = w/2;

            // 1. INPUT (Volante Virtual com Espelho)
            let targetSteer = 0;
            if(pose) {
                const lw = pose.keypoints.find(o=>o.name==='left_wrist');
                const rw = pose.keypoints.find(o=>o.name==='right_wrist');
                if(lw && rw && lw.score>0.3 && rw.score>0.3) {
                    // M√£o Direita desce (Y aumenta) -> Vira para Direita (Positivo)
                    // Fator de sensibilidade: 0.1
                    targetSteer = (rw.y - lw.y) * 0.1; 
                    if(k.speed < 80) k.speed += 0.5; // Acelera
                } else {
                    k.speed *= 0.95; // Freia
                }
            }
            k.steer += (targetSteer - k.steer) * 0.1; // Suaviza√ß√£o

            // 2. F√çSICA
            k.pos += k.speed * 0.01;
            k.curve = Math.sin(k.pos * 0.5) * 2; // Curva procedural
            
            k.playerX += k.steer * (k.speed/500); // Movimento do carro
            k.playerX -= k.curve * (k.speed/1000); // Centr√≠fuga da curva

            // Colis√£o Grama
            if(Math.abs(k.playerX) > 1.2) { k.speed *= 0.9; }

            // 3. DESENHO
            Gfx.drawRoad(ctx, w, h, k.pos, k.curve);
            
            const carScreenX = cx + (k.playerX * w * 0.3);
            Gfx.drawKart(ctx, carScreenX, h-80, k.steer);

            return Math.floor(k.pos * 10);
        }
    };

    /**
     * ==========================================
     * üèÉ JOGO 2: TEMPLE RUNNER
     * ==========================================
     */
    const Runner = {
        lane: 0, score: 0, frame: 0, obstacles: [], noseBase: 0, jumping: false, jumpH: 0,
        init: () => { Runner.score=0; Runner.obstacles=[]; Runner.noseBase=0; Engine.msg("CORRA!"); },
        update: (ctx, w, h, pose) => {
            const r = Runner;
            const cx = w/2;
            r.frame++;

            // 1. INPUT (Espelho Corrigido)
            if(pose) {
                const nose = pose.keypoints.find(o=>o.name==='nose');
                if(nose && nose.score > 0.4) {
                    // A. Lane (Invertido: Esquerda F√≠sica = Direita Tela)
                    // C√¢mera Raw: 0 (Esq) -> 640 (Dir).
                    if(nose.x < 240) r.lane = 1;      // Direita
                    else if(nose.x > 400) r.lane = -1; // Esquerda
                    else r.lane = 0;

                    // B. Pulo (Nose Y sobe drasticamente)
                    if(r.noseBase === 0) r.noseBase = nose.y;
                    
                    // Se o nariz subir 40px acima da base -> PULO
                    if(nose.y < r.noseBase - 40 && !r.jumping) {
                        r.jumping = true;
                        r.jumpH = 20; // Impulso inicial
                        Sfx.jump();
                    }
                    // Atualiza base lentamente para adaptar altura
                    r.noseBase = (r.noseBase * 0.95) + (nose.y * 0.05);
                }
            }

            // F√≠sica do Pulo
            let yOffset = 0;
            if(r.jumping) {
                yOffset = Math.sin(r.jumpH) * 100; // Arco do pulo
                r.jumpH -= 0.5; // Gravidade
                if(r.jumpH < -5) r.jumping = false; // Aterrissou
            }

            // Spawner
            if(r.frame % 60 === 0) r.obstacles.push({l: Math.floor(Math.random()*3)-1, z: 1000, type: 'rock'});

            // Render
            ctx.clearRect(0,0,w,h);
            ctx.fillStyle = '#27ae60'; ctx.fillRect(0,h/2,w,h/2); // Ch√£o
            ctx.fillStyle = '#2980b9'; ctx.fillRect(0,0,w,h/2); // C√©u

            // Obst√°culos
            r.obstacles.forEach((o, i) => {
                o.z -= 15; // Velocidade
                if(o.z < -100) { r.obstacles.splice(i,1); r.score+=10; }
                
                const scale = 500/(o.z+100);
                if(scale > 0) {
                    const ox = cx + (o.l * 200 * scale);
                    const oy = h/2 + (50 * scale);
                    const sz = 60 * scale;

                    ctx.fillStyle = '#5d4037';
                    ctx.fillRect(ox-sz/2, oy, sz, sz);

                    // Colis√£o
                    // Se estiver perto E na mesma lane E N√ÉO estiver pulando alto
                    if(o.z < 50 && o.z > -50 && o.l === r.lane && !r.jumping) {
                        Engine.gameOver(r.score);
                    }
                }
            });

            // Player
            const px = cx + (r.lane * 150);
            const py = h - 100 - (r.jumping ? 100 : 0); // Sobe visualmente se pular
            Gfx.drawRunner(ctx, px, py, r.frame, r.jumping);

            return r.score;
        }
    };

    /**
     * ==========================================
     * ü•ä JOGO 3: PUNCH-OUT AR
     * ==========================================
     */
    const Box = {
        hp: 100, score: 0, hitFrame: 0, targets: [], lastSpawn: 0,
        init: () => { Box.hp=100; Box.score=0; Engine.msg("FIGHT!"); },
        update: (ctx, w, h, pose) => {
            const b = Box;
            const now = Date.now();
            const cx = w/2;

            ctx.clearRect(0,0,w,h);
            ctx.fillStyle='#2c3e50'; ctx.fillRect(0,0,w,h); // Ring background

            // 1. INPUT (Punhos)
            let punches = [];
            if(pose) {
                const lw = pose.keypoints.find(o=>o.name==='left_wrist');
                const rw = pose.keypoints.find(o=>o.name==='right_wrist');
                // Map Video X to Screen X (Mirror)
                const mapX = x => w - (x/640 * w);
                const mapY = y => y/480 * h;

                if(lw && lw.score>0.3) punches.push({x: mapX(lw.x), y: mapY(lw.y)});
                if(rw && rw.score>0.3) punches.push({x: mapX(rw.x), y: mapY(rw.y)});

                // Desenha Luvas
                ctx.fillStyle='red';
                punches.forEach(p => {
                    ctx.beginPath(); ctx.arc(p.x, p.y, 30, 0, Math.PI*2); ctx.fill();
                });
            }

            // 2. BOSS (Rob√¥)
            if(b.hitFrame > 0) b.hitFrame--;
            Gfx.drawRobot(ctx, w, h, b.hitFrame);

            // 3. PONTOS FRACOS (Targets)
            if(now - b.lastSpawn > 1000) {
                // Alvo aparece em torno do rob√¥ (centro da tela)
                b.targets.push({
                    x: cx + (Math.random()-0.5)*200, 
                    y: h/2 + (Math.random()-0.5)*200,
                    r: 40, spawn: now
                });
                b.lastSpawn = now;
            }

            // Render & Hit Logic
            b.targets.forEach((t, i) => {
                const age = (now - t.spawn)/1500;
                if(age>1) { b.targets.splice(i,1); return; } // Missed

                // Draw Target
                ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2);
                ctx.strokeStyle = '#f1c40f'; ctx.lineWidth=4; ctx.stroke();
                
                // Check Hit
                punches.forEach(p => {
                    if(Math.hypot(p.x-t.x, p.y-t.y) < t.r + 30) {
                        b.targets.splice(i,1);
                        b.score += 50;
                        b.hp -= 10;
                        b.hitFrame = 10; // Shake robot
                        Sfx.hit();
                    }
                });
            });

            // Update UI HP
            document.getElementById('hp-bar').style.width = b.hp + '%';
            if(b.hp <= 0) { 
                b.hp = 100; // Reset boss
                b.score += 1000;
                Engine.msg("K.O.!");
            }

            return b.score;
        }
    };
</script>
</body>
</html>
