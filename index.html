<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>thIAguinho Wii: Motion Engine Pro</title>
    
    <!-- TENSORFLOW.JS (IA Core) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <!-- TAILWIND CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- FONTS -->
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;700;900&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary: #00F0FF;
            --secondary: #FF003C;
            --bg-dark: #050505;
            --hud-bg: rgba(0, 20, 40, 0.85);
        }

        body {
            background-color: var(--bg-dark);
            font-family: 'Nunito', sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            color: white;
            margin: 0;
        }

        /* LAYOUT & CAMADAS */
        #viewport { position: relative; width: 100vw; height: 100vh; overflow: hidden; background: #000; }
        
        #video-feed {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Espelho Visual */
            opacity: 0.2; 
            z-index: 0;
            filter: grayscale(100%) contrast(1.2);
        }

        #game-canvas { position: absolute; inset: 0; z-index: 10; width: 100%; height: 100%; }

        #ui-layer { 
            position: absolute; inset: 0; z-index: 20; pointer-events: none; 
            display: flex; flex-direction: column;
        }
        .interactive { pointer-events: auto; }

        /* CARDS DO MENU */
        .game-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0.01) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-left: 4px solid var(--primary);
            border-radius: 12px;
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            position: relative; overflow: hidden;
        }
        .game-card:active { transform: scale(0.98); background: rgba(255, 255, 255, 0.1); }
        
        .card-icon { font-size: 2.5rem; margin-right: 1rem; filter: drop-shadow(0 0 10px var(--primary)); }

        /* LOGO ESTILIZADO */
        .brand-logo { font-weight: 900; letter-spacing: -2px; font-style: italic; }
        .brand-ia { color: var(--primary); text-shadow: 0 0 20px var(--primary); }

        /* LOADERS & HUD */
        .loader {
            width: 50px; height: 50px; border: 3px solid rgba(255,255,255,0.1);
            border-top-color: var(--primary); border-radius: 50%;
            animation: rotation 0.8s linear infinite;
        }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .hud-panel {
            background: var(--hud-bg);
            border: 1px solid rgba(0, 240, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.1);
            border-radius: 8px;
            padding: 8px 16px;
            display: flex; flex-direction: column; align-items: center;
        }

        /* ANIMA√á√ïES DE INTERFACE */
        @keyframes scanline {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }
        .scanline::after {
            content: ""; position: absolute; inset: 0;
            background: linear-gradient(to bottom, transparent, rgba(0, 240, 255, 0.1), transparent);
            animation: scanline 4s linear infinite;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="viewport">
        <!-- V√çDEO (FUNDO PROCESSADO) -->
        <video id="video-feed" autoplay muted playsinline></video>
        
        <!-- RENDERIZA√á√ÉO DO JOGO -->
        <canvas id="game-canvas"></canvas>

        <!-- INTERFACE DE USU√ÅRIO -->
        <div id="ui-layer">
            
            <!-- TELA DE LOADING -->
            <div id="screen-load" class="absolute inset-0 bg-black z-50 flex flex-col items-center justify-center interactive scanline">
                <div class="loader mb-8"></div>
                <h1 class="text-4xl text-white brand-logo">th<span class="brand-ia">IA</span>guinho</h1>
                <p class="text-slate-500 text-xs mt-4 uppercase tracking-[0.4em]">Calibrando Sensores...</p>
                <div id="debug-log" class="text-[10px] text-cyan-500 mt-4 font-mono h-4">Inicializando TensorFlow...</div>
            </div>

            <!-- MENU PRINCIPAL -->
            <div id="screen-menu" class="hidden absolute inset-0 bg-black/90 backdrop-blur-xl z-40 flex flex-col items-center justify-center interactive p-6">
                
                <div class="mb-12 text-center">
                    <h1 class="text-7xl text-white brand-logo leading-none drop-shadow-2xl italic transform -skew-x-6">
                        MOTION<span class="brand-ia">PRO</span>
                    </h1>
                    <div class="mt-3 flex justify-center gap-2">
                        <span class="px-2 py-0.5 border border-cyan-500 text-cyan-500 text-[9px] font-bold uppercase rounded">Engine v2.0</span>
                        <span class="px-2 py-0.5 border border-pink-500 text-pink-500 text-[9px] font-bold uppercase rounded">WebGPU Ready</span>
                    </div>
                </div>

                <div class="grid grid-cols-1 gap-4 w-full max-w-sm">
                    <!-- KART -->
                    <div onclick="App.launch('kart')" class="game-card flex items-center p-5 cursor-pointer hover:bg-white/5">
                        <div class="card-icon">üèéÔ∏è</div>
                        <div class="flex-1">
                            <h2 class="text-xl font-bold text-white uppercase italic">Pro Racing</h2>
                            <p class="text-xs text-slate-400">Dire√ß√£o Real 1:1 ‚Ä¢ F√≠sica de Bra√ßos</p>
                        </div>
                    </div>

                    <!-- RUN -->
                    <div onclick="App.launch('run')" class="game-card flex items-center p-5 cursor-pointer hover:bg-white/5" style="border-left-color: #10B981;">
                        <div class="card-icon">üèÉ</div>
                        <div class="flex-1">
                            <h2 class="text-xl font-bold text-white uppercase italic">Street Mirror</h2>
                            <p class="text-xs text-slate-400">C√≥pia Corporal ‚Ä¢ Sem Delay</p>
                        </div>
                    </div>

                    <!-- BOXE -->
                    <div onclick="App.launch('beat')" class="game-card flex items-center p-5 cursor-pointer hover:bg-white/5" style="border-left-color: #FF003C;">
                        <div class="card-icon">ü•ä</div>
                        <div class="flex-1">
                            <h2 class="text-xl font-bold text-white uppercase italic">Impact Box</h2>
                            <p class="text-xs text-slate-400">Detec√ß√£o de Velocidade e For√ßa</p>
                        </div>
                    </div>
                </div>
                
                <p class="text-slate-600 text-[10px] mt-12 text-center max-w-xs font-mono">
                    SENSORIAMENTO ATIVO.<br>MANTENHA O CORPO INTEIRO NO QUADRO.
                </p>
            </div>

            <!-- HUD (IN-GAME) -->
            <div id="screen-hud" class="hidden w-full h-full flex flex-col justify-between pointer-events-none p-4 safe-area">
                <!-- Top Bar -->
                <div class="flex justify-between items-start w-full">
                    <div class="hud-panel">
                        <span class="text-[9px] text-cyan-400 font-bold uppercase tracking-widest mb-1">SCORE</span>
                        <span id="hud-score" class="text-3xl font-black text-white leading-none font-mono">0</span>
                    </div>
                    
                    <button onclick="App.stop()" class="interactive w-12 h-12 rounded bg-red-600/20 border border-red-500 text-red-500 font-bold flex items-center justify-center active:bg-red-600 active:text-white transition-all">
                        ‚úï
                    </button>
                </div>
                
                <!-- Feedback Central -->
                <div id="hud-msg" class="absolute inset-0 flex flex-col items-center justify-center pointer-events-none z-30">
                    <h2 id="hud-msg-text" class="text-6xl font-black text-white italic transform -skew-x-12 drop-shadow-[0_0_15px_rgba(0,0,0,1)] opacity-0 transition-all duration-100 scale-50"></h2>
                </div>

                <!-- Bottom Stats -->
                <div class="w-full flex flex-col items-center gap-2">
                    <!-- Gauge de Energia/Velocidade -->
                    <div id="hud-gauge-container" class="hidden w-64 h-2 bg-slate-800 rounded-full overflow-hidden border border-slate-600">
                        <div id="hud-gauge-fill" class="h-full bg-gradient-to-r from-cyan-600 to-cyan-300 w-0 transition-all duration-75"></div>
                    </div>
                    <span id="hud-debug" class="text-[9px] text-cyan-500 font-mono opacity-70">SYSTEM READY</span>
                </div>
            </div>

        </div>
    </div>

    <script>
        /**
         * =========================================================================
         * 1. PHYSICS & MOTION ENGINE (N√çVEL ARQUITETURA S√äNIOR)
         * - Tratamento vetorial de movimento
         * - Separa√ß√£o Raw vs Smooth
         * - Corre√ß√£o de Espelhamento (Esquerda F√≠sica = Esquerda Tela)
         * =========================================================================
         */
        const Motion = {
            detector: null,
            video: document.getElementById('video-feed'),
            // Pose State
            raw: null,      // Dados puros do frame atual
            smooth: null,   // Dados suavizados para renderiza√ß√£o
            prev: null,     // Frame anterior para c√°lculo de velocidade
            
            // Configura√ß√£o da F√≠sica
            smoothingFactor: 0.15, // 0 = Travado, 1 = Sem suaviza√ß√£o (Instant√¢neo)
            lastFrameTime: 0,

            init: async () => {
                const log = (t) => document.getElementById('debug-log').innerText = t;
                try {
                    await tf.setBackend('webgl');
                    log("Acessando Hardware de C√¢mera...");
                    
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            facingMode: 'user', 
                            width: { ideal: 640 }, 
                            height: { ideal: 480 },
                            frameRate: { ideal: 60 }
                        },
                        audio: false
                    });
                    Motion.video.srcObject = stream;
                    await new Promise(r => Motion.video.onloadedmetadata = r);
                    Motion.video.play();

                    log("Carregando MoveNet (Lightning)...");
                    const config = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING };
                    Motion.detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, config);
                    return true;
                } catch (e) {
                    alert("Erro Cr√≠tico de Hardware: " + e.message);
                    return false;
                }
            },

            // Loop de Captura e Processamento F√≠sico
            update: async () => {
                if (!Motion.detector) return null;
                
                const now = performance.now();
                const dt = (now - Motion.lastFrameTime) / 1000;
                Motion.lastFrameTime = now;

                const poses = await Motion.detector.estimatePoses(Motion.video);
                if (poses.length === 0) return null;

                const rawKeypoints = poses[0].keypoints;
                const score = poses[0].score;

                // --- MAPERAMENTO DE COORDENADAS (CR√çTICO) ---
                // O v√≠deo √© 640x480. A tela √© vari√°vel.
                // O v√≠deo est√° espelhado visualmente via CSS, mas os dados do TF v√™m crus.
                // Para 1:1, precisamos inverter o X matematicamente: X_Tela = Width - X_Video
                
                const vw = 640; const vh = 480;
                const sw = window.innerWidth; const sh = window.innerHeight;
                
                // Scale "Cover" logic
                const scale = Math.max(sw / vw, sh / vh);
                const ox = (sw - (vw * scale)) / 2;
                const oy = (sh - (vh * scale)) / 2;

                const processPoint = (kp) => ({
                    // INVERS√ÉO DO EIXO X PARA CORRESPONDER AO ESPELHO
                    x: sw - (((vw - kp.x) * scale) + ox), 
                    y: (kp.y * scale) + oy,
                    score: kp.score,
                    name: kp.name
                });

                const currentRaw = {
                    nose: processPoint(rawKeypoints.find(k => k.name === 'nose')),
                    shoulders: {
                        l: processPoint(rawKeypoints.find(k => k.name === 'left_shoulder')),
                        r: processPoint(rawKeypoints.find(k => k.name === 'right_shoulder'))
                    },
                    wrists: {
                        l: processPoint(rawKeypoints.find(k => k.name === 'left_wrist')),
                        r: processPoint(rawKeypoints.find(k => k.name === 'right_wrist'))
                    },
                    elbows: {
                        l: processPoint(rawKeypoints.find(k => k.name === 'left_elbow')),
                        r: processPoint(rawKeypoints.find(k => k.name === 'right_elbow'))
                    },
                    score: score,
                    dt: Math.min(dt, 0.1) // Cap lag spikes
                };

                // C√°lculo de centro e largura do corpo (Normaliza√ß√£o)
                if (currentRaw.shoulders.l.score > 0.3 && currentRaw.shoulders.r.score > 0.3) {
                    currentRaw.center = {
                        x: (currentRaw.shoulders.l.x + currentRaw.shoulders.r.x) / 2,
                        y: (currentRaw.shoulders.l.y + currentRaw.shoulders.r.y) / 2
                    };
                    currentRaw.width = Math.hypot(
                        currentRaw.shoulders.r.x - currentRaw.shoulders.l.x, 
                        currentRaw.shoulders.r.y - currentRaw.shoulders.l.y
                    );
                } else {
                    currentRaw.center = Motion.prev ? Motion.prev.center : {x: sw/2, y: sh/2};
                    currentRaw.width = Motion.prev ? Motion.prev.width : 100;
                }

                // --- VELOCIDADE (PHYSICS) ---
                // Calculada sobre o RAW para detec√ß√£o de impactos (socos)
                currentRaw.velocity = { l: 0, r: 0 };
                if (Motion.prev) {
                    const distL = Math.hypot(currentRaw.wrists.l.x - Motion.prev.wrists.l.x, currentRaw.wrists.l.y - Motion.prev.wrists.l.y);
                    const distR = Math.hypot(currentRaw.wrists.r.x - Motion.prev.wrists.r.x, currentRaw.wrists.r.y - Motion.prev.wrists.r.y);
                    // Pixels por segundo normalizados pela largura do corpo (consistente para perto/longe)
                    currentRaw.velocity.l = (distL / currentRaw.dt) / currentRaw.width; 
                    currentRaw.velocity.r = (distR / currentRaw.dt) / currentRaw.width;
                }

                Motion.prev = currentRaw; // Salva estado raw para f√≠sica do pr√≥ximo frame

                // --- SUAVIZA√á√ÉO (VISUAL) ---
                // Interpola√ß√£o Linear Simples (Lerp) para remover jitter na renderiza√ß√£o
                if (!Motion.smooth) Motion.smooth = JSON.parse(JSON.stringify(currentRaw)); // Clone deep

                const lerp = (start, end, amt) => (1 - amt) * start + amt * end;
                const lerpPoint = (curr, target) => {
                    curr.x = lerp(curr.x, target.x, Motion.smoothingFactor);
                    curr.y = lerp(curr.y, target.y, Motion.smoothingFactor);
                    curr.score = target.score;
                };

                lerpPoint(Motion.smooth.nose, currentRaw.nose);
                lerpPoint(Motion.smooth.shoulders.l, currentRaw.shoulders.l);
                lerpPoint(Motion.smooth.shoulders.r, currentRaw.shoulders.r);
                lerpPoint(Motion.smooth.wrists.l, currentRaw.wrists.l);
                lerpPoint(Motion.smooth.wrists.r, currentRaw.wrists.r);
                lerpPoint(Motion.smooth.elbows.l, currentRaw.elbows.l);
                lerpPoint(Motion.smooth.elbows.r, currentRaw.elbows.r);
                lerpPoint(Motion.smooth.center, currentRaw.center);
                Motion.smooth.width = lerp(Motion.smooth.width, currentRaw.width, Motion.smoothingFactor);
                Motion.smooth.velocity = currentRaw.velocity; // Velocity n√£o suaviza, queremos o pico

                return Motion.smooth;
            }
        };

        /**
         * =========================================================================
         * 2. MOTOR GR√ÅFICO (Canvas 2D Otimizado)
         * =========================================================================
         */
        const Gfx = {
            canvas: document.getElementById('game-canvas'),
            ctx: null,
            width: 0, height: 0,
            
            init: () => {
                Gfx.ctx = Gfx.canvas.getContext('2d', { alpha: true, desynchronized: true });
                window.addEventListener('resize', Gfx.resize);
                Gfx.resize();
            },

            resize: () => {
                Gfx.width = window.innerWidth;
                Gfx.height = window.innerHeight;
                const dpr = window.devicePixelRatio || 1;
                Gfx.canvas.width = Gfx.width * dpr;
                Gfx.canvas.height = Gfx.height * dpr;
                Gfx.ctx.scale(dpr, dpr);
            },

            clear: () => Gfx.ctx.clearRect(0, 0, Gfx.width, Gfx.height),

            // Utilit√°rio para desenhar esqueleto
            drawSkeleton: (pose, color = '#00F0FF') => {
                const ctx = Gfx.ctx;
                ctx.strokeStyle = color; ctx.lineWidth = 4; ctx.lineCap = 'round';
                ctx.fillStyle = color;

                const connect = (p1, p2) => {
                    if(p1.score > 0.3 && p2.score > 0.3) {
                        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                    }
                };

                // Bra√ßos
                connect(pose.shoulders.l, pose.elbows.l);
                connect(pose.elbows.l, pose.wrists.l);
                connect(pose.shoulders.r, pose.elbows.r);
                connect(pose.elbows.r, pose.wrists.r);
                // Ombros
                connect(pose.shoulders.l, pose.shoulders.r);

                // Joints
                [pose.shoulders.l, pose.shoulders.r, pose.elbows.l, pose.elbows.r, pose.wrists.l, pose.wrists.r].forEach(p => {
                    if(p.score > 0.3) { ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI*2); ctx.fill(); }
                });
            }
        };

        /**
         * =========================================================================
         * 3. GAME LOGIC: KART (DIRE√á√ÉO VETORIAL)
         * - Calcula √¢ngulo real entre pulsos
         * - Zona de detec√ß√£o de "M√£os no Volante"
         * =========================================================================
         */
        class GameKart {
            constructor() {
                this.speed = 0;
                this.maxSpeed = 180;
                this.steering = 0; // -1 (Esq) a 1 (Dir)
                this.carX = 0; // -1.5 a 1.5 (Pista)
                this.curve = 0;
                this.score = 0;
                this.obstacles = [];
                this.handsOnWheel = false;
                
                document.getElementById('hud-gauge-container').classList.remove('hidden');
                App.msg("LEVANTE AS M√ÉOS", "#00F0FF");
            }

            update(pose, dt) {
                const ctx = Gfx.ctx;
                const w = Gfx.width; const h = Gfx.height;
                const steeringZoneY = h * 0.7; // Linha imagin√°ria do volante

                // 1. INPUT DE DIRE√á√ÉO (MATEM√ÅTICA PURA)
                this.handsOnWheel = false;
                if (pose.wrists.l.score > 0.4 && pose.wrists.r.score > 0.4) {
                    // Verifica se as m√£os est√£o na altura correta (acima da cintura aprox)
                    if (pose.wrists.l.y < h * 0.8 && pose.wrists.r.y < h * 0.8) {
                        this.handsOnWheel = true;

                        // Vetor Delta entre pulsos
                        const dy = pose.wrists.r.y - pose.wrists.l.y;
                        const dx = pose.wrists.r.x - pose.wrists.l.x;
                        
                        // Arco Tangente calcula o √¢ngulo exato em radianos
                        let angle = Math.atan2(dy, dx);
                        
                        // O "Zero" (Reto) n√£o √© 0 radianos, mas depende da inclina√ß√£o dos ombros
                        // Corre√ß√£o din√¢mica baseada nos ombros (para n√£o virar se o corpo inclinar)
                        const shoulderAngle = Math.atan2(pose.shoulders.r.y - pose.shoulders.l.y, pose.shoulders.r.x - pose.shoulders.l.x);
                        let steerAngle = angle - shoulderAngle;

                        // Clamp e Normaliza√ß√£o (-1 a 1)
                        // Aprox 45 graus (0.8 rad) de rota√ß√£o m√°xima
                        this.steering = Math.max(-1, Math.min(1, steerAngle / 0.8));
                        
                        // Deadzone pequena
                        if (Math.abs(this.steering) < 0.1) this.steering = 0;

                        // Acelera√ß√£o
                        this.speed = Math.min(this.maxSpeed, this.speed + 100 * dt);
                    }
                }

                if (!this.handsOnWheel) {
                    // Auto-centraliza√ß√£o e freio
                    this.steering *= 0.9;
                    this.speed *= 0.95; 
                    
                    // Desenha zona guia
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255, 0, 60, 0.5)';
                    ctx.setLineDash([10, 10]);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(w*0.1, h*0.5); ctx.lineTo(w*0.9, h*0.5);
                    ctx.moveTo(w*0.1, h*0.8); ctx.lineTo(w*0.9, h*0.8);
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(255,0,60,0.8)';
                    ctx.font = '12px monospace';
                    ctx.fillText("MANTENHA M√ÉOS AQUI", w/2 - 60, h*0.65);
                    ctx.restore();
                }

                // 2. F√çSICA DO CARRO
                // Curva da pista procedural (Simplex noise simplificado)
                const t = Date.now() / 2000;
                this.curve = Math.sin(t) * 0.5 + Math.cos(t * 0.3) * 0.3;

                // Movimento lateral = Dire√ß√£o - For√ßa Centr√≠fuga da curva
                const lateralForce = (this.steering * 2.5) - (this.curve * (this.speed/this.maxSpeed) * 1.5);
                this.carX += lateralForce * dt;

                // Limites da pista
                if (this.carX < -1.4) { this.carX = -1.4; this.speed *= 0.9; }
                if (this.carX > 1.4) { this.carX = 1.4; this.speed *= 0.9; }

                this.score += Math.floor(this.speed * dt);

                // Obst√°culos
                if (Math.random() < 0.02 && this.speed > 50) {
                    this.obstacles.push({x: (Math.random()-0.5)*2.5, z: 0});
                }

                // 3. RENDERIZA√á√ÉO
                Gfx.clear();
                
                // Horizonte
                const hz = h * 0.4;
                
                // Pista (Trap√©zio)
                ctx.fillStyle = '#1e293b';
                ctx.beginPath();
                const trackTopX = w/2 + (this.curve * 200);
                const trackBotX = w/2 + (this.carX * -300); // Movimento inverso do mundo
                const trackTopW = 20;
                const trackBotW = w * 2;
                
                ctx.moveTo(trackTopX - trackTopW, hz);
                ctx.lineTo(trackTopX + trackTopW, hz);
                ctx.lineTo(trackBotX + trackBotW, h);
                ctx.lineTo(trackBotX - trackBotW, h);
                ctx.fill();

                // Grid Cyberpunk
                ctx.strokeStyle = '#00F0FF'; ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(trackTopX, hz); ctx.lineTo(trackBotX, h); // Centro
                ctx.stroke();

                // Render Obst√°culos
                for(let i = this.obstacles.length - 1; i >= 0; i--) {
                    let obs = this.obstacles[i];
                    obs.z += (this.speed * 0.005) * dt;
                    
                    if(obs.z > 1.2) { this.obstacles.splice(i, 1); continue; }

                    const persp = obs.z;
                    const oW = 80 * persp;
                    const oH = 80 * persp;
                    // Proje√ß√£o 3D simplificada
                    const screenX = trackTopX + (trackBotX - trackTopX) * persp + (obs.x * w * 0.5 * persp);
                    const screenY = hz + (h - hz) * persp;

                    ctx.fillStyle = '#FF003C';
                    ctx.fillRect(screenX - oW/2, screenY - oH, oW, oH);

                    // Colis√£o
                    if (obs.z > 0.8 && obs.z < 0.95) {
                        if (Math.abs(screenX - w/2) < w * 0.15) {
                            this.speed = 20;
                            App.msg("COLIS√ÉO!", "#FF003C");
                            ctx.fillStyle = 'white'; ctx.fillRect(0,0,w,h);
                        }
                    }
                }

                // Render Volante Virtual (HUD)
                const wheelX = w/2;
                const wheelY = h - 100;
                const radius = 60;
                
                ctx.save();
                ctx.translate(wheelX, wheelY);
                ctx.rotate(this.steering);
                
                // Aro
                ctx.beginPath(); ctx.arc(0,0, radius, 0, Math.PI*2);
                ctx.lineWidth = 10; 
                ctx.strokeStyle = this.handsOnWheel ? '#00F0FF' : '#555'; 
                ctx.stroke();
                
                // Centro
                ctx.fillStyle = this.handsOnWheel ? '#00F0FF' : '#333';
                ctx.beginPath(); ctx.arc(0,0, 15, 0, Math.PI*2); ctx.fill();
                ctx.fillRect(-radius, -5, radius*2, 10); // Barra central
                
                ctx.restore();

                // HUD Stats
                document.getElementById('hud-gauge-fill').style.width = (this.speed/this.maxSpeed)*100 + '%';
                document.getElementById('hud-debug').innerText = `SPD: ${Math.floor(this.speed)} | STR: ${this.steering.toFixed(2)}`;
                
                return this.score;
            }
        }

        /**
         * =========================================================================
         * 4. GAME LOGIC: STREET RUN (1:1 BODY MIRROR)
         * - Sem "runEnergy" falsa.
         * - Se o usu√°rio para, o boneco para no frame.
         * - Pulo baseado na altura do ombro.
         * =========================================================================
         */
        class GameRun {
            constructor() {
                this.distance = 0;
                this.playerY = 0; // Altura do pulo
                this.jumpVel = 0;
                this.baseShoulderY = 0;
                this.isCalibrated = false;
                this.obstacles = [];
                this.lastX = 0;
                this.speed = 0;
                
                App.msg("FIQUE EM P√â", "#10B981");
                document.getElementById('hud-gauge-container').classList.remove('hidden');
            }

            update(pose, dt) {
                const ctx = Gfx.ctx;
                const w = Gfx.width; const h = Gfx.height;

                // 1. CALIBRA√á√ÉO INSTANT√ÇNEA
                if (pose.shoulders.l.score > 0.5) {
                    if (!this.isCalibrated) {
                        this.baseShoulderY = pose.center.y;
                        this.isCalibrated = true;
                    }
                    // Recalibra suavemente para baixo (caso o user mude de posi√ß√£o)
                    if (pose.center.y > this.baseShoulderY) {
                        this.baseShoulderY = pose.center.y;
                    }
                }

                // 2. DETEC√á√ÉO DE CORRIDA (REAL)
                // Analisa a oscila√ß√£o vertical do centro de massa (bouncing de corrida)
                // E a oscila√ß√£o dos pulsos
                const bodyBounce = Math.abs(pose.center.y - (Motion.prev?.center.y || pose.center.y)) / dt;
                const wristSpeed = (pose.velocity.l + pose.velocity.r);
                
                // Se houver movimento significativo, gera velocidade
                if (bodyBounce > 50 || wristSpeed > 3.0) {
                    this.speed = Math.min(60, this.speed + 200 * dt);
                } else {
                    this.speed = 0; // PARA IMEDIATAMENTE (Requisito "Stop no mesmo frame")
                }

                // 3. DETEC√á√ÉO DE PULO
                // Se os ombros subirem drasticamente acima da base calibrada
                const jumpThreshold = pose.width * 0.4; // 40% da largura do ombro
                const heightDiff = this.baseShoulderY - pose.center.y;
                
                if (this.playerY === 0 && heightDiff > jumpThreshold) {
                    this.jumpVel = 15;
                    this.playerY = 1;
                    App.msg("PULO!", "#10B981");
                }

                // F√≠sica do Pulo (Gravidade)
                if (this.playerY > 0) {
                    this.playerY += this.jumpVel * dt * 5; // Multiplicador para ajuste de tempo
                    this.jumpVel -= 40 * dt; // Gravidade
                    if (this.playerY <= 0) { this.playerY = 0; this.jumpVel = 0; }
                }

                // Progresso
                this.distance += (this.speed * 0.5) * dt;

                // Obst√°culos
                if (Math.random() < 0.015 && this.speed > 10) {
                    this.obstacles.push({x: 0, z: 0, type: Math.random() > 0.5 ? 'low' : 'high'});
                }

                // 4. RENDERIZA√á√ÉO
                Gfx.clear();

                // Fundo Scifi
                ctx.fillStyle = '#050505'; ctx.fillRect(0,0,w,h);
                
                // Chao (Grid move com distance)
                const gridOffset = (this.distance * 100) % 100;
                ctx.strokeStyle = '#10B981'; ctx.lineWidth = 1;
                ctx.beginPath();
                for(let i=0; i<w; i+=100) { ctx.moveTo(i, h/2); ctx.lineTo(i - (w/2) + (i*2), h); } // Perspectiva fake
                for(let i=0; i<h/2; i+=50) { 
                    let y = h - i + gridOffset; 
                    if(y > h/2) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
                }
                ctx.stroke();

                // Obst√°culos
                for(let i = this.obstacles.length - 1; i >= 0; i--) {
                    let obs = this.obstacles[i];
                    obs.z += (this.speed * 0.01 + 5) * dt; // Vem na sua dire√ß√£o mesmo parado (esteira)
                    
                    if(obs.z > 20) { this.obstacles.splice(i, 1); continue; }

                    const scale = obs.z / 5;
                    if(scale < 0.1) continue;

                    const size = 50 * scale;
                    const drawX = w/2;
                    const drawY = h/2 + (scale * 200);
                    
                    ctx.fillStyle = obs.type === 'low' ? '#F59E0B' : '#EF4444';
                    
                    // Ajusta altura baseado no tipo
                    const objY = obs.type === 'low' ? drawY : drawY - (150 * scale);
                    ctx.fillRect(drawX - size/2, objY, size, size);

                    // Colis√£o 2D Simples (Hitbox sobreposta)
                    // Player est√° fixo no centro X, mas tem Y vari√°vel
                    if (scale > 0.8 && scale < 1.2) {
                        const playerHitboxY = this.playerY * 50; // Altura do pulo em pixels
                        
                        let hit = false;
                        if (obs.type === 'low' && playerHitboxY < 50) hit = true; // Trope√ßou
                        if (obs.type === 'high' && playerHitboxY > 50) hit = true; // Bateu cabe√ßa

                        if (hit) {
                            this.speed = 0;
                            App.msg("ERROU!", "#EF4444");
                            ctx.fillStyle = 'white'; ctx.fillRect(0,0,w,h);
                            this.obstacles.splice(i, 1);
                        }
                    }
                }

                // AVATAR MIRROR (1:1 REAL)
                // Desenhamos o esqueleto do usu√°rio COMO O PERSONAGEM
                // Aplicamos offset Y baseado no pulo do jogo (n√£o do v√≠deo)
                
                ctx.save();
                // O avatar fica no centro da tela X, mas segue os movimentos relativos do usu√°rio
                const avatarCenterX = w/2;
                const userCenterX = pose.center.x;
                const offsetX = avatarCenterX - userCenterX;
                
                // Sobe o avatar inteiro baseado no pulo da engine f√≠sica
                const jumpOffset = this.playerY * -150; 

                ctx.translate(offsetX, jumpOffset);
                
                // Glow effect
                ctx.shadowBlur = 20; ctx.shadowColor = '#10B981';
                Gfx.drawSkeleton(pose, '#10B981');
                
                // Cabe√ßa (Avatar)
                ctx.fillStyle = 'white';
                ctx.beginPath(); ctx.arc(pose.nose.x, pose.nose.y, 20, 0, Math.PI*2); ctx.fill();
                
                ctx.restore();

                document.getElementById('hud-gauge-fill').style.width = (this.speed/60)*100 + '%';
                return Math.floor(this.distance);
            }
        }

        /**
         * =========================================================================
         * 5. GAME LOGIC: RHYTHM BOX (PHYSICS BASED)
         * - Detecta Soco real (Velocidade > Threshold)
         * - Dire√ß√£o do soco vs Alvo
         * =========================================================================
         */
        class GameBox {
            constructor() {
                this.score = 0;
                this.targets = [];
                this.spawnTimer = 0;
                this.combo = 0;
                
                App.msg("GUARDA ALTA!", "#FF003C");
                document.getElementById('hud-gauge-container').classList.add('hidden');
            }

            update(pose, dt) {
                const ctx = Gfx.ctx;
                const w = Gfx.width; const h = Gfx.height;

                // Spawn Alvos
                this.spawnTimer += dt;
                if (this.spawnTimer > 1.2 - (Math.min(0.8, this.combo * 0.05))) { // Fica mais r√°pido
                    this.spawnTimer = 0;
                    const side = Math.random() > 0.5 ? 'left' : 'right';
                    this.targets.push({
                        x: side === 'left' ? w * 0.25 : w * 0.75,
                        y: h * 0.3 + (Math.random() * h * 0.3),
                        r: 60,
                        life: 1.5,
                        maxLife: 1.5,
                        side: side,
                        hit: false
                    });
                }

                // Verifica Colis√£o (Physics Check)
                // Hit = (M√£o dentro do alvo) AND (Velocidade da m√£o > Threshold)
                const PUNCH_THRESHOLD = 4.0; // Velocidade alta requerida

                this.targets.forEach(t => {
                    if (t.hit) return;

                    // Escolhe a m√£o correta para o lado (Cruzado tamb√©m vale)
                    // Mas vamos priorizar m√£o esquerda para alvo esquerdo para simplificar
                    const handL = pose.wrists.l;
                    const handR = pose.wrists.r;
                    
                    const checkHit = (hand, velocity) => {
                        const dist = Math.hypot(hand.x - t.x, hand.y - t.y);
                        if (dist < t.r && velocity > PUNCH_THRESHOLD) {
                            return true;
                        }
                        return false;
                    };

                    let isHit = false;
                    if (checkHit(handL, pose.velocity.l)) isHit = true;
                    if (checkHit(handR, pose.velocity.r)) isHit = true;

                    if (isHit) {
                        t.hit = true;
                        this.combo++;
                        this.score += 100 * this.combo;
                        App.msg(`${this.combo}X COMBO!`, "#FF003C");
                        
                        // Impact FX
                        ctx.fillStyle = 'white';
                        ctx.beginPath(); ctx.arc(t.x, t.y, 80, 0, Math.PI*2); ctx.fill();
                    }
                });

                // Render
                Gfx.clear();
                
                // Desenha Alvos
                for(let i = this.targets.length - 1; i >= 0; i--) {
                    let t = this.targets[i];
                    t.life -= dt;
                    
                    if (t.life <= 0 || t.hit) {
                        if (!t.hit) { this.combo = 0; App.msg("MISS", "#666"); }
                        this.targets.splice(i, 1);
                        continue;
                    }

                    // Anima√ß√£o de pulso
                    const scale = t.life / t.maxLife;
                    const alpha = scale;
                    
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.r, 0, Math.PI*2);
                    ctx.fillStyle = t.side === 'left' ? `rgba(0, 240, 255, ${alpha})` : `rgba(255, 0, 60, ${alpha})`;
                    ctx.fill();
                    
                    // Anel externo encolhendo (indicador de tempo)
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.r * scale, 0, Math.PI*2);
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }

                // Desenha Luvas (Sobre as m√£os do user)
                const drawGlove = (kp, vel, color) => {
                    if (kp.score < 0.3) return;
                    
                    // Tamanho reage √† velocidade (impacto visual)
                    const size = 30 + Math.min(20, vel * 5);
                    
                    // Trail/Rastro
                    ctx.shadowBlur = size; ctx.shadowColor = color;
                    
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.arc(kp.x, kp.y, size, 0, Math.PI*2); ctx.fill();
                    
                    // Reflexo
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    ctx.beginPath(); ctx.arc(kp.x - size*0.3, kp.y - size*0.3, size*0.2, 0, Math.PI*2); ctx.fill();
                    
                    ctx.shadowBlur = 0;
                };

                drawGlove(pose.wrists.l, pose.velocity.l, '#00F0FF');
                drawGlove(pose.wrists.r, pose.velocity.r, '#FF003C');

                // HUD Debug Velocity
                document.getElementById('hud-debug').innerText = `L-VEL: ${pose.velocity.l.toFixed(1)} | R-VEL: ${pose.velocity.r.toFixed(1)}`;

                return this.score;
            }
        }

        /**
         * =========================================================================
         * 6. APP CORE (Main Loop)
         * =========================================================================
         */
        const App = {
            game: null,
            rafId: null,
            lastTime: 0,

            init: async () => {
                const ready = await Motion.init();
                if (ready) {
                    document.getElementById('screen-load').classList.add('hidden');
                    document.getElementById('screen-menu').classList.remove('hidden');
                    document.getElementById('screen-menu').classList.add('flex');
                    Gfx.init();
                }
            },

            launch: (type) => {
                document.getElementById('screen-menu').classList.remove('flex');
                document.getElementById('screen-menu').classList.add('hidden');
                document.getElementById('screen-hud').classList.remove('hidden');
                document.getElementById('screen-hud').classList.add('flex');
                
                // Reinicia Motion state
                Motion.prev = null;
                Motion.smooth = null;

                if (type === 'kart') App.game = new GameKart();
                if (type === 'run') App.game = new GameRun();
                if (type === 'beat') App.game = new GameBox();

                App.lastTime = performance.now();
                App.loop();
            },

            stop: () => {
                cancelAnimationFrame(App.rafId);
                App.game = null;
                Gfx.clear();
                document.getElementById('screen-hud').classList.remove('flex');
                document.getElementById('screen-hud').classList.add('hidden');
                document.getElementById('screen-menu').classList.remove('hidden');
                document.getElementById('screen-menu').classList.add('flex');
            },

            msg: (text, color='#FFF') => {
                const el = document.getElementById('hud-msg-text');
                el.innerText = text;
                el.style.color = color;
                el.style.opacity = 1;
                el.style.transform = "scale(1.2) skewX(-12deg)";
                
                // Reset ap√≥s anima√ß√£o
                clearTimeout(App.msgTimeout);
                App.msgTimeout = setTimeout(() => {
                    el.style.opacity = 0;
                    el.style.transform = "scale(0.5) skewX(-12deg)";
                }, 800);
            },

            loop: async () => {
                if (!App.game) return;

                const now = performance.now();
                const dt = Math.min((now - App.lastTime) / 1000, 0.1); // Cap delta time
                App.lastTime = now;

                const pose = await Motion.update();
                
                if (pose) {
                    const score = App.game.update(pose, dt);
                    document.getElementById('hud-score').innerText = score;
                }

                App.rafId = requestAnimationFrame(App.loop);
            }
        };

        window.onload = App.init;

    </script>
</body>
</html
