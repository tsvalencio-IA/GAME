<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0f172a">
    <title>thIAguinho Wii: ULTIMATE</title>
    
    <!-- TENSORFLOW (CORE AI) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <!-- ESTILOS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Rajdhani:wght@500;700;900&display=swap" rel="stylesheet">

    <style>
        :root {
            --neon-blue: #00F3FF;
            --neon-pink: #FF0055;
            --neon-green: #00FF9D;
            --bg-dark: #050505;
        }

        body {
            background-color: var(--bg-dark);
            font-family: 'Rajdhani', sans-serif;
            margin: 0; overflow: hidden;
            touch-action: none; user-select: none;
            color: white;
        }

        #game-container { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
        
        /* V√çDEO (ESPELHO) */
        #webcam {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            filter: brightness(0.7) contrast(1.2);
            z-index: 0;
        }

        /* CANVAS (JOGO) */
        #game-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
        }

        /* UI */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; pointer-events: none;
            padding: env(safe-area-inset-top) 20px 20px 20px;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .interactive { pointer-events: auto; cursor: pointer; }

        /* CARDS */
        .game-card {
            background: rgba(20, 20, 30, 0.95);
            border: 1px solid rgba(255,255,255,0.1);
            border-left: 4px solid #fff;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.8);
            transition: all 0.2s;
            position: relative; overflow: hidden;
        }
        .game-card:active { transform: scale(0.96); background: rgba(50,50,60,1); }
        .game-card.kart { border-color: var(--neon-blue); }
        .game-card.run { border-color: var(--neon-green); }
        .game-card.box { border-color: var(--neon-pink); }

        /* HUD */
        .hud-panel {
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px);
            border-radius: 99px;
            padding: 8px 24px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }

        .title-font { font-family: 'Black Ops One', cursive; }
        
        /* STATUS */
        #status-dot {
            width: 10px; height: 10px; border-radius: 50%;
            background-color: #333; margin-right: 8px;
            transition: background-color 0.2s;
        }
        .status-ok { background-color: #00FF9D !important; box-shadow: 0 0 10px #00FF9D; }
        .status-bad { background-color: #FF0055 !important; box-shadow: 0 0 10px #FF0055; }
    </style>
</head>
<body>

    <div id="game-container">
        <video id="webcam" autoplay muted playsinline></video>
        <canvas id="game-canvas"></canvas>

        <div id="ui-layer">
            
            <!-- LOADER -->
            <div id="screen-load" class="absolute inset-0 bg-black z-50 flex flex-col items-center justify-center interactive">
                <div class="w-16 h-16 border-4 border-gray-800 border-t-cyan-400 rounded-full animate-spin mb-4"></div>
                <h1 class="text-4xl text-white title-font tracking-widest">thIAguinho</h1>
                <p id="load-status" class="text-cyan-400 text-xs mt-2 font-mono">INICIANDO C√ÇMERA...</p>
            </div>

            <!-- MENU -->
            <div id="screen-menu" class="hidden absolute inset-0 bg-black/95 backdrop-blur-md z-40 flex flex-col items-center justify-center interactive p-4">
                <h1 class="text-6xl md:text-8xl text-white title-font mb-2 text-center">
                    th<span class="text-[var(--neon-blue)]">IA</span>guinho
                </h1>
                <p class="text-gray-400 tracking-[0.5em] text-xs mb-10">WII EDITION</p>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 w-full max-w-4xl">
                    <!-- KART -->
                    <div onclick="App.launch('kart')" class="game-card kart h-32 flex flex-col items-center justify-center interactive group">
                        <div class="text-4xl mb-2">üèéÔ∏è</div>
                        <h2 class="text-xl font-bold text-white italic">KART</h2>
                        <p class="text-[10px] text-gray-400 uppercase">Segure o Volante</p>
                    </div>
                    <!-- RUN -->
                    <div onclick="App.launch('run')" class="game-card run h-32 flex flex-col items-center justify-center interactive group">
                        <div class="text-4xl mb-2">üèÉ</div>
                        <h2 class="text-xl font-bold text-white italic">RUN</h2>
                        <p class="text-[10px] text-gray-400 uppercase">Corra no Lugar</p>
                    </div>
                    <!-- BOX -->
                    <div onclick="App.launch('box')" class="game-card box h-32 flex flex-col items-center justify-center interactive group">
                        <div class="text-4xl mb-2">ü•ä</div>
                        <h2 class="text-xl font-bold text-white italic">BOXE</h2>
                        <p class="text-[10px] text-gray-400 uppercase">Soque as Bolhas</p>
                    </div>
                </div>
            </div>

            <!-- HUD -->
            <div id="screen-hud" class="hidden w-full h-full flex-col justify-between pointer-events-none">
                <!-- Top -->
                <div class="flex justify-between items-start w-full">
                    <div class="hud-panel flex flex-col items-center">
                        <span class="text-[10px] text-[var(--neon-blue)] font-bold uppercase tracking-widest">SCORE</span>
                        <span id="hud-score" class="text-3xl font-mono font-bold text-white leading-none">0</span>
                    </div>
                    <button onclick="App.stop()" class="interactive w-12 h-12 rounded-full bg-red-500/80 border border-red-500 text-white font-bold flex items-center justify-center backdrop-blur">‚úï</button>
                </div>

                <!-- Center Msg -->
                <div id="hud-msg" class="absolute inset-0 flex items-center justify-center pointer-events-none">
                    <h2 id="msg-text" class="text-6xl font-black text-white italic drop-shadow-2xl opacity-0 transition-all duration-200" style="-webkit-text-stroke: 2px black;"></h2>
                </div>

                <!-- Bottom Status -->
                <div class="w-full flex justify-center pb-4">
                    <div class="flex items-center bg-black/60 px-4 py-2 rounded-full">
                        <div id="status-dot"></div>
                        <span id="hud-status" class="text-xs font-bold text-white uppercase">Aguardando IA...</span>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
        /**
         * =========================================================================
         * 1. MOTION ENGINE (Core IA + F√≠sica)
         * =========================================================================
         */
        const Motion = {
            detector: null,
            video: document.getElementById('webcam'),
            prevPose: null,
            lastTime: 0,
            
            init: async () => {
                const status = document.getElementById('load-status');
                try {
                    await tf.setBackend('webgl');
                    status.innerText = "LIGANDO C√ÇMERA...";
                    
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } },
                        audio: false
                    });
                    Motion.video.srcObject = stream;
                    await new Promise(r => Motion.video.onloadedmetadata = r);
                    Motion.video.play();

                    status.innerText = "CARREGANDO REDE NEURAL...";
                    const config = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING };
                    Motion.detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, config);
                    return true;
                } catch (e) {
                    alert("Erro: " + e.message);
                    return false;
                }
            },

            update: async (w, h) => {
                if (!Motion.detector) return null;
                
                const now = performance.now();
                const dt = Math.min((now - Motion.lastTime)/1000, 0.1);
                Motion.lastTime = now;

                let poses = [];
                try {
                    poses = await Motion.detector.estimatePoses(Motion.video);
                } catch (e) { return null; }

                // Se n√£o detectou ningu√©m
                if (poses.length === 0) {
                    document.getElementById('status-dot').className = 'status-bad';
                    document.getElementById('hud-status').innerText = "CORPO N√ÉO DETECTADO";
                    return null; 
                }

                // Detectou!
                document.getElementById('status-dot').className = 'status-ok';
                document.getElementById('hud-status').innerText = "SISTEMA ATIVO";

                const raw = poses[0].keypoints;
                const vw = Motion.video.videoWidth;
                const vh = Motion.video.videoHeight;
                
                // Corre√ß√£o de Aspect Ratio (Cover)
                const scale = Math.max(w / vw, h / vh);
                const ox = (w - (vw * scale)) / 2;
                const oy = (h - (vh * scale)) / 2;

                // **CORRE√á√ÉO DE ESPELHO**: Inverter X para bater com o CSS scaleX(-1)
                const map = (kp) => ({
                    x: w - (((vw - kp.x) * scale) + ox), 
                    y: (kp.y * scale) + oy,
                    score: kp.score
                });

                const find = n => raw.find(k => k.name === n);
                
                const p = {
                    nose: map(find('nose')),
                    shoulders: { l: map(find('left_shoulder')), r: map(find('right_shoulder')) },
                    wrists: { l: map(find('left_wrist')), r: map(find('right_wrist')) },
                    elbows: { l: map(find('left_elbow')), r: map(find('right_elbow')) },
                    dt: dt
                };

                // Largura do corpo para normaliza√ß√£o
                p.bodyWidth = Math.hypot(p.shoulders.l.x - p.shoulders.r.x, p.shoulders.l.y - p.shoulders.r.y) || 100;
                p.center = { x: (p.shoulders.l.x + p.shoulders.r.x)/2, y: (p.shoulders.l.y + p.shoulders.r.y)/2 };

                // Suaviza√ß√£o (Lerp) para reduzir tremedeira
                if (Motion.prevPose) {
                    const alpha = 0.5; // Fator de suaviza√ß√£o
                    const lerp = (a, b) => a * alpha + b * (1-alpha);
                    p.center.x = lerp(p.center.x, Motion.prevPose.center.x);
                    p.center.y = lerp(p.center.y, Motion.prevPose.center.y);
                    p.wrists.l.x = lerp(p.wrists.l.x, Motion.prevPose.wrists.l.x);
                    p.wrists.l.y = lerp(p.wrists.l.y, Motion.prevPose.wrists.l.y);
                    p.wrists.r.x = lerp(p.wrists.r.x, Motion.prevPose.wrists.r.x);
                    p.wrists.r.y = lerp(p.wrists.r.y, Motion.prevPose.wrists.r.y);
                }
                
                Motion.prevPose = p;
                return p;
            }
        };

        /**
         * =========================================================================
         * 2. GRAPHICS ENGINE
         * =========================================================================
         */
        const Gfx = {
            canvas: document.getElementById('game-canvas'),
            ctx: null,
            width: 0, height: 0,

            init: () => {
                Gfx.ctx = Gfx.canvas.getContext('2d');
                window.addEventListener('resize', Gfx.resize);
                Gfx.resize();
            },

            resize: () => {
                Gfx.width = window.innerWidth;
                Gfx.height = window.innerHeight;
                Gfx.canvas.width = Gfx.width;
                Gfx.canvas.height = Gfx.height;
            },

            clear: () => Gfx.ctx.clearRect(0, 0, Gfx.width, Gfx.height),

            drawSkeleton: (pose, color) => {
                if (!pose) return;
                const ctx = Gfx.ctx;
                ctx.save();
                ctx.strokeStyle = color; ctx.lineWidth = 4; ctx.lineCap = 'round';
                ctx.shadowBlur = 10; ctx.shadowColor = color;
                
                // Desenhar conex√µes sempre, mesmo com score baixo (use a √∫ltima posi√ß√£o conhecida ou suavizada)
                // Threshold reduzido para 0.2
                const line = (p1, p2) => {
                    if (p1.score > 0.2 && p2.score > 0.2) {
                        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                    }
                };
                
                line(pose.shoulders.l, pose.shoulders.r);
                line(pose.shoulders.l, pose.elbows.l); line(pose.elbows.l, pose.wrists.l);
                line(pose.shoulders.r, pose.elbows.r); line(pose.elbows.r, pose.wrists.r);
                
                // Cabe√ßa
                if (pose.nose.score > 0.2) {
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(pose.nose.x, pose.nose.y, 8, 0, Math.PI*2); ctx.fill();
                }
                ctx.restore();
            }
        };

        /**
         * =========================================================================
         * JOGO 1: TURBO KART (Volante Realista)
         * =========================================================================
         */
        class GameKart {
            constructor() {
                this.speed = 20; // Come√ßa com velocidade m√≠nima (Auto-Gas)
                this.angle = 0;
                this.carX = 0;
                this.score = 0;
                this.curve = 0;
                this.obstacles = [];
                App.msg("START!", "#00F3FF");
            }

            update(pose, ctx, w, h) {
                // INPUT: √Çngulo entre os pulsos
                // Se n√£o detectar pulsos, mant√©m o √¢ngulo (n√£o zera bruscamente)
                if (pose && pose.wrists.l.score > 0.2 && pose.wrists.r.score > 0.2) {
                    const dy = pose.wrists.r.y - pose.wrists.l.y;
                    const dx = pose.wrists.r.x - pose.wrists.l.x;
                    let targetAngle = Math.atan2(dy, dx);
                    
                    // Clamp
                    targetAngle = Math.max(-1.2, Math.min(1.2, targetAngle));
                    
                    // Suaviza√ß√£o
                    this.angle += (targetAngle - this.angle) * 5 * pose.dt;
                    
                    // Acelera mais se tiver controle
                    this.speed = Math.min(150, this.speed + 40 * pose.dt);
                } else {
                    // Sem m√£os: desacelera e centraliza devagar
                    this.speed = Math.max(20, this.speed - 20 * pose.dt);
                    this.angle *= 0.95;
                }

                // F√≠sica do Carro
                this.curve = Math.sin(Date.now() / 2000) * 0.6; // Curva da pista
                this.carX += (this.angle * 3.0 - (this.curve * this.speed/100)) * pose.dt;
                
                // Limites Pista
                if (this.carX < -1.5) { this.carX = -1.5; this.speed *= 0.8; }
                if (this.carX > 1.5) { this.carX = 1.5; this.speed *= 0.8; }

                this.score += Math.floor(this.speed * pose.dt);

                // Obst√°culos
                if (Math.random() < 0.02 && this.speed > 30) this.obstacles.push({x: (Math.random()-0.5)*2.5, z: 0});

                // RENDER
                ctx.clearRect(0,0,w,h);
                const hz = h * 0.4; // Horizonte
                
                // Pista
                ctx.fillStyle = '#222';
                ctx.beginPath();
                const cTop = w/2 + (this.curve * 200);
                const cBot = w/2 + (this.carX * -300); // Movimento relativo
                ctx.moveTo(cTop - 10, hz); ctx.lineTo(cTop + 10, hz);
                ctx.lineTo(cBot + w*1.5, h); ctx.lineTo(cBot - w*1.5, h);
                ctx.fill();
                
                // Bordas
                ctx.strokeStyle = '#00F3FF'; ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(cTop-10, hz); ctx.lineTo(cBot-w*1.5, h);
                ctx.moveTo(cTop+10, hz); ctx.lineTo(cBot+w*1.5, h);
                ctx.stroke();

                // Obst√°culos
                this.obstacles.forEach((obs, i) => {
                    obs.z += (this.speed * 0.002) * pose.dt * 60;
                    if (obs.z > 1.2) { this.obstacles.splice(i, 1); return; }
                    
                    const scale = obs.z * obs.z;
                    const drawY = hz + (obs.z * (h - hz));
                    const roadX = cTop + (cBot - cTop) * obs.z;
                    const drawX = roadX + (obs.x * w * 0.5 * obs.z);
                    const size = 50 * scale;

                    ctx.fillStyle = '#FF0055';
                    ctx.fillRect(drawX - size/2, drawY - size, size, size);

                    // Colis√£o
                    if (obs.z > 0.85 && obs.z < 0.95 && Math.abs(drawX - w/2) < 80) {
                        this.speed = 10;
                        App.msg("BATIDA!", "#FF0055");
                        ctx.fillStyle = 'white'; ctx.fillRect(0,0,w,h);
                        this.obstacles.splice(i,1);
                    }
                });

                // Carro (Traseira)
                const carY = h - 150;
                ctx.save();
                ctx.translate(w/2, carY);
                ctx.rotate(this.angle * 0.3); // Inclina√ß√£o visual
                ctx.fillStyle = '#00F3FF';
                ctx.beginPath(); ctx.roundRect(-50, -30, 100, 60, 10); ctx.fill(); // Chassi
                ctx.fillStyle = '#FF0055'; 
                ctx.beginPath(); ctx.arc(-35, 0, 10, 0, Math.PI*2); ctx.fill(); // Luz Esq
                ctx.beginPath(); ctx.arc(35, 0, 10, 0, Math.PI*2); ctx.fill();  // Luz Dir
                ctx.restore();

                // Volante Virtual (HUD)
                const wx = w/2, wy = 150;
                ctx.save();
                ctx.translate(wx, wy);
                ctx.rotate(this.angle);
                ctx.beginPath(); ctx.arc(0,0, 60, 0, Math.PI*2);
                ctx.lineWidth = 8; 
                ctx.strokeStyle = '#00F3FF';
                ctx.stroke();
                // Raios
                ctx.beginPath(); ctx.moveTo(-60,0); ctx.lineTo(60,0); ctx.stroke();
                ctx.restore();

                // Esqueleto
                Gfx.drawSkeleton(pose, '#00F3FF');
                
                return this.score;
            }
        }

        /**
         * =========================================================================
         * JOGO 2: STREET RUN (Corrida F√≠sica)
         * =========================================================================
         */
        class GameRun {
            constructor() {
                this.score = 0;
                this.speed = 20; // Velocidade base (sempre anda um pouco)
                this.lane = 0;
                this.playerY = 0;
                this.jumpVel = 0;
                this.runEnergy = 0;
                this.lastY = 0;
                this.obstacles = [];
                App.msg("GO!", "#00FF9D");
            }

            update(pose, ctx, w, h) {
                if (pose && pose.shoulders.l.score > 0.2) {
                    const midX = pose.center.x;
                    const midY = pose.center.y;

                    // 1. Dire√ß√£o Lateral
                    const diffX = midX - (w/2);
                    if (diffX < -w * 0.15) this.lane = -1;
                    else if (diffX > w * 0.15) this.lane = 1;
                    else this.lane = 0;

                    // 2. Corrida (Oscila√ß√£o)
                    if (!this.lastY) this.lastY = midY;
                    const delta = Math.abs(midY - this.lastY);
                    this.lastY = midY;

                    // Se oscilar, ganha velocidade extra
                    if (delta > 3) {
                        this.runEnergy = Math.min(1, this.runEnergy + 5.0 * pose.dt);
                    } else {
                        this.runEnergy = Math.max(0, this.runEnergy - 0.5 * pose.dt);
                    }
                    this.speed = 20 + (this.runEnergy * 80);

                    // 3. Pulo (M√£os para cima OU Impulso corporal)
                    const handsUp = pose.wrists.l.y < pose.nose.y;
                    if (this.playerY === 0 && handsUp) {
                        this.jumpVel = 20; this.playerY = 1;
                        App.msg("PULO!", "#00FF9D");
                    }
                }

                // F√≠sica
                this.distance = (this.distance || 0) + this.speed * pose.dt;
                this.score = Math.floor(this.distance * 10);
                
                if (this.playerY > 0) {
                    this.playerY += this.jumpVel * pose.dt * 2;
                    this.jumpVel -= 60 * pose.dt;
                    if (this.playerY <= 0) { this.playerY = 0; this.jumpVel = 0; }
                }

                // Obst√°culos
                if (Math.random() < 0.02 && this.speed > 5) this.obstacles.push({lane: Math.floor(Math.random()*3)-1, z:0});

                // RENDER
                ctx.clearRect(0,0,w,h);
                const hz = h * 0.4;
                
                // Ch√£o e Grid
                ctx.fillStyle = '#111'; ctx.beginPath(); ctx.moveTo(w/2, hz); ctx.lineTo(w*1.5, h); ctx.lineTo(-w*0.5, h); ctx.fill();
                ctx.strokeStyle = '#00FF9D'; ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(w/2, hz); ctx.lineTo(w*0.2, h);
                ctx.moveTo(w/2, hz); ctx.lineTo(w*0.5, h);
                ctx.moveTo(w/2, hz); ctx.lineTo(w*0.8, h);
                ctx.stroke();

                // Obst√°culos
                this.obstacles.forEach((obs, i) => {
                    obs.z += (this.speed * 0.005 + 0.02) * 60 * pose.dt;
                    if (obs.z > 1.2) { this.obstacles.splice(i,1); return; }

                    const scale = obs.z;
                    const roadW = w * 2 * scale;
                    const drawX = (w/2) + (obs.lane * roadW * 0.15);
                    const drawY = hz + (obs.z * (h-hz));
                    const size = 50 * scale;

                    ctx.fillStyle = '#FF9900';
                    ctx.fillRect(drawX - size/2, drawY - size, size, size);

                    // Colis√£o
                    if (obs.z > 0.85 && obs.z < 0.95 && obs.lane === this.lane && this.playerY === 0) {
                        this.speed = 10; this.runEnergy = 0;
                        App.msg("BATIDA!", "red");
                        ctx.fillStyle = 'white'; ctx.fillRect(0,0,w,h);
                        this.obstacles.splice(i,1);
                    }
                });

                // Avatar (Esqueleto)
                ctx.save();
                const jumpPx = this.playerY * -200;
                const lanePx = this.lane * 100;
                ctx.translate(lanePx, jumpPx);
                Gfx.drawSkeleton(pose, '#00FF9D');
                ctx.restore();

                return this.score;
            }
        }

        /**
         * =========================================================================
         * JOGO 3: RHYTHM BOX (Academia)
         * =========================================================================
         */
        class GameBox {
            constructor() {
                this.score = 0;
                this.targets = [];
                this.timer = 0;
                this.beatInterval = 1.0;
                App.msg("FIGHT!", "#FF0055");
            }

            update(pose, ctx, w, h) {
                // Spawn R√≠tmico
                this.timer += pose.dt;
                if (this.timer > this.beatInterval) {
                    this.timer = 0;
                    const side = Math.random() > 0.5 ? 'L' : 'R';
                    this.targets.push({
                        x: side === 'L' ? w*0.2 : w*0.8,
                        y: h*0.3 + Math.random() * h*0.3,
                        r: 10,
                        active: true,
                        color: side === 'L' ? '#00F3FF' : '#FF0055',
                        hit: false
                    });
                    this.beatInterval = Math.max(0.5, this.beatInterval * 0.98); // Acelera
                }

                ctx.clearRect(0,0,w,h);
                Gfx.drawSkeleton(pose, '#555');

                this.targets.forEach(t => {
                    if (!t.active) return;
                    t.r += 80 * pose.dt; // Cresce

                    // Desenha
                    ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2);
                    ctx.fillStyle = t.color + '44'; ctx.fill();
                    ctx.strokeStyle = t.color; ctx.lineWidth = 4; ctx.stroke();

                    // Anel de timing
                    if (Math.abs(t.r - 60) < 10) { ctx.strokeStyle = '#fff'; ctx.stroke(); }

                    // Hit Detection (Facilitado)
                    if (pose && t.r > 40 && !t.hit) {
                        const hand = (t.color.includes('F3FF')) ? pose.wrists.l : pose.wrists.r;
                        const dist = Math.hypot(hand.x - t.x, hand.y - t.y);
                        
                        // Hitbox gigante (80px)
                        if (dist < 80) {
                            t.active = false; t.hit = true;
                            this.score += 100;
                            App.msg("HIT!", t.color);
                            // Explos√£o
                            ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(t.x, t.y, 80, 0, Math.PI*2); ctx.fill();
                        }
                    }

                    if (t.r > 120) { t.active = false; App.msg("MISS", "#555"); }
                });

                this.targets = this.targets.filter(t => t.active);

                // Luvas
                if (pose) {
                    const glove = (p, c) => {
                        if(p.score > 0.2) { // Score baixo aceit√°vel
                            ctx.fillStyle = c; ctx.beginPath(); ctx.arc(p.x, p.y, 40, 0, Math.PI*2); ctx.fill();
                        }
                    };
                    glove(pose.wrists.l, '#00F3FF'); glove(pose.wrists.r, '#FF0055');
                }

                return this.score;
            }
        }

        /**
         * =========================================================================
         * APP CONTROLLER
         * =========================================================================
         */
        const App = {
            game: null,
            loopId: null,

            init: async () => {
                Gfx.init();
                const ready = await Motion.init();
                if (ready) {
                    document.getElementById('screen-load').classList.add('hidden');
                    document.getElementById('screen-menu').classList.remove('hidden');
                    document.getElementById('screen-menu').classList.add('flex');
                }
            },

            launch: (type) => {
                document.getElementById('screen-menu').classList.remove('flex');
                document.getElementById('screen-menu').classList.add('hidden');
                document.getElementById('screen-hud').classList.remove('hidden');
                document.getElementById('screen-hud').classList.add('flex');

                if (type === 'kart') App.game = new GameKart();
                if (type === 'run') App.game = new GameRun();
                if (type === 'box') App.game = new GameBox();

                App.loop();
            },

            stop: () => {
                cancelAnimationFrame(App.loopId);
                App.game = null;
                document.getElementById('screen-hud').classList.add('hidden');
                document.getElementById('screen-menu').classList.remove('hidden');
                document.getElementById('screen-menu').classList.add('flex');
                Gfx.clear();
            },

            msg: (text, color) => {
                const el = document.getElementById('msg-text');
                el.innerText = text; el.style.color = color;
                el.style.opacity = 1; el.style.transform = "scale(1.5)";
                setTimeout(() => { el.style.opacity = 0; el.style.transform = "scale(1)"; }, 400);
            },

            loop: async () => {
                if (!App.game) return;
                
                // Sempre tentar pegar pose, se falhar, retorna nulo mas n√£o quebra loop
                const pose = await Motion.update(Gfx.width, Gfx.height);
                
                if (pose) {
                    const score = App.game.update(pose, Gfx.ctx, Gfx.width, Gfx.height);
                    document.getElementById('hud-score').innerText = score;
                } else {
                    // Se n√£o tiver pose, o jogo continua rodando a l√≥gica b√°sica (anima√ß√µes)
                    // mas n√£o recebe input.
                }

                App.loopId = requestAnimationFrame(App.loop);
            }
        };

        window.onload = App.init;

    </script>
</body>
</html>
