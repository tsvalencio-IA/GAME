<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>thIAguinho WII: ULTIMATE</title>
    
    <!-- CORE: TENSORFLOW.JS -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <!-- UI: TAILWIND -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- FONTS -->
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Rajdhani:wght@500;700;900&display=swap" rel="stylesheet">

    <style>
        :root {
            --neon-blue: #00F3FF;
            --neon-pink: #FF0055;
            --neon-green: #00FF9D;
            --bg-dark: #050505;
        }

        body {
            background-color: var(--bg-dark);
            font-family: 'Rajdhani', sans-serif;
            margin: 0; overflow: hidden;
            touch-action: none; user-select: none;
            color: white;
            width: 100vw; height: 100vh;
        }

        /* LAYOUT */
        #game-container { position: relative; width: 100%; height: 100%; overflow: hidden; }
        
        /* V√çDEO (ESPELHO) */
        #webcam {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            filter: brightness(0.5) contrast(1.2);
            z-index: 0;
            pointer-events: none;
        }

        /* CANVAS (JOGO) */
        #game-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        /* UI LAYER - CORRE√á√ÉO DE CLIQUES */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20;
            display: flex; flex-direction: column; justify-content: space-between;
            pointer-events: none; /* Deixa passar clique para o canvas se necess√°rio, mas... */
        }
        
        /* ...filhos com pointer-events: auto recebem clique */
        #ui-layer > * { pointer-events: auto; }

        .interactive { cursor: pointer; active: scale: 0.95; transition: transform 0.1s; }

        /* CARDS */
        .game-card {
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid rgba(255,255,255,0.1);
            border-left: 6px solid #fff;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: all 0.2s;
            position: relative; overflow: hidden;
        }
        .game-card:active { transform: scale(0.96); background: rgba(50,50,60,1); }
        .game-card.kart { border-color: var(--neon-blue); }
        .game-card.run { border-color: var(--neon-green); }
        .game-card.box { border-color: var(--neon-pink); }

        /* HUD */
        .hud-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px);
            border-radius: 99px;
            padding: 8px 24px;
            box-shadow: 0 0 20px rgba(0,243,255,0.2);
            pointer-events: none;
        }

        .title-font { font-family: 'Black Ops One', cursive; }
        
        /* STATUS DOT */
        .status-dot {
            width: 12px; height: 12px; border-radius: 50%;
            background-color: #333; margin-right: 8px;
            box-shadow: 0 0 5px currentColor;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <video id="webcam" autoplay muted playsinline></video>
        <canvas id="game-canvas"></canvas>

        <div id="ui-layer" class="p-6">
            
            <!-- LOADER -->
            <div id="screen-load" class="absolute inset-0 bg-black z-50 flex flex-col items-center justify-center pointer-events-auto">
                <div class="w-16 h-16 border-4 border-gray-800 border-t-cyan-400 rounded-full animate-spin mb-6"></div>
                <h1 class="text-5xl text-white title-font tracking-widest mb-2">thIAguinho</h1>
                <p id="load-status" class="text-cyan-400 text-sm font-mono animate-pulse">INICIALIZANDO SISTEMA...</p>
                <button id="btn-force-start" class="hidden mt-8 px-6 py-2 border border-white/20 rounded text-xs text-gray-500 hover:text-white" onclick="App.forceStart()">FOR√áAR IN√çCIO (SEM C√ÇMERA)</button>
            </div>

            <!-- MENU -->
            <div id="screen-menu" class="hidden absolute inset-0 bg-black/90 backdrop-blur-xl z-40 flex flex-col items-center justify-center p-4 pointer-events-auto overflow-y-auto">
                <div class="mb-10 text-center">
                    <h1 class="text-6xl md:text-8xl text-white title-font leading-none">
                        th<span class="text-[var(--neon-blue)]">IA</span>guinho
                    </h1>
                    <div class="flex items-center justify-center gap-2 mt-2">
                        <div class="h-px w-10 bg-gray-600"></div>
                        <p class="text-gray-400 tracking-[0.4em] text-xs font-bold">WII CONSOLE</p>
                        <div class="h-px w-10 bg-gray-600"></div>
                    </div>
                </div>

                <div class="grid grid-cols-1 gap-4 w-full max-w-sm">
                    <!-- KART -->
                    <div onclick="App.launch('kart')" class="game-card kart h-24 flex items-center px-6 interactive group cursor-pointer">
                        <div class="text-5xl mr-6 group-hover:scale-110 transition-transform">üèéÔ∏è</div>
                        <div class="flex-1">
                            <h2 class="text-2xl font-bold text-white italic">NEON KART</h2>
                            <p class="text-[10px] text-gray-400 uppercase">Segure o Volante</p>
                        </div>
                        <div class="text-2xl font-black text-[var(--neon-blue)]">GO</div>
                    </div>
                    <!-- RUN -->
                    <div onclick="App.launch('run')" class="game-card run h-24 flex items-center px-6 interactive group cursor-pointer">
                        <div class="text-5xl mr-6 group-hover:scale-110 transition-transform">üèÉ</div>
                        <div class="flex-1">
                            <h2 class="text-2xl font-bold text-white italic">STREET RUN</h2>
                            <p class="text-[10px] text-gray-400 uppercase">Corra e Pule</p>
                        </div>
                        <div class="text-2xl font-black text-[var(--neon-green)]">GO</div>
                    </div>
                    <!-- BOX -->
                    <div onclick="App.launch('box')" class="game-card box h-24 flex items-center px-6 interactive group cursor-pointer">
                        <div class="text-5xl mr-6 group-hover:scale-110 transition-transform">ü•ä</div>
                        <div class="flex-1">
                            <h2 class="text-2xl font-bold text-white italic">RHYTHM BOX</h2>
                            <p class="text-[10px] text-gray-400 uppercase">Soco no Ritmo</p>
                        </div>
                        <div class="text-2xl font-black text-[var(--neon-pink)]">GO</div>
                    </div>
                </div>
                
                <div class="mt-8 text-center text-gray-600 text-xs">
                    <p>Posicione-se a 2 metros da c√¢mera.</p>
                </div>
            </div>

            <!-- HUD (IN GAME) -->
            <div id="screen-hud" class="hidden absolute inset-0 flex-col justify-between p-6 pointer-events-none z-30">
                <!-- Top -->
                <div class="flex justify-between items-start pointer-events-auto">
                    <div class="hud-panel flex flex-col items-center">
                        <span class="text-[9px] text-[var(--neon-blue)] font-bold uppercase tracking-widest">SCORE</span>
                        <span id="hud-score" class="text-4xl font-mono font-bold text-white leading-none">0</span>
                    </div>
                    <button onclick="App.stop()" class="w-14 h-14 rounded-full bg-red-600/20 border-2 border-red-500 text-red-500 font-bold text-xl backdrop-blur interactive flex items-center justify-center hover:bg-red-600 hover:text-white transition-colors">‚úï</button>
                </div>

                <!-- Center Msg -->
                <div id="hud-msg" class="absolute inset-0 flex items-center justify-center pointer-events-none">
                    <h2 id="msg-text" class="text-6xl md:text-8xl font-black text-white italic drop-shadow-2xl opacity-0 transition-all duration-200 transform scale-50" style="-webkit-text-stroke: 2px black;"></h2>
                </div>

                <!-- Bottom Status -->
                <div class="w-full flex justify-center pointer-events-auto">
                    <div class="flex items-center bg-black/80 border border-white/10 px-5 py-2 rounded-full backdrop-blur">
                        <div id="status-dot" class="status-dot bg-red-500"></div>
                        <span id="hud-status" class="text-xs font-bold text-gray-300 uppercase tracking-wider">AGUARDANDO...</span>
                    </div>
                </div>
            </div>
            
            <!-- GAME OVER -->
            <div id="screen-gameover" class="hidden absolute inset-0 bg-black/95 z-50 flex flex-col items-center justify-center pointer-events-auto p-6">
                <h1 class="text-6xl text-white title-font mb-4 text-center">GAME OVER</h1>
                <div class="bg-white/10 p-8 rounded-2xl border border-white/20 text-center mb-8 w-full max-w-sm">
                    <p class="text-gray-400 text-xs uppercase tracking-widest mb-2">PONTUA√á√ÉO FINAL</p>
                    <p id="final-score" class="text-8xl font-mono font-bold text-[var(--neon-blue)]">0</p>
                </div>
                <button onclick="App.showMenu()" class="w-full max-w-sm py-4 bg-white text-black font-black text-xl rounded-full hover:scale-105 transition-transform interactive">
                    VOLTAR AO MENU
                </button>
            </div>

        </div>
    </div>

    <script>
        /**
         * =========================================================================
         * 1. MOTION ENGINE (IA + F√çSICA)
         * =========================================================================
         */
        const Motion = {
            detector: null,
            video: document.getElementById('webcam'),
            prevPose: null,
            lastTime: 0,
            
            init: async () => {
                const status = document.getElementById('load-status');
                try {
                    await tf.setBackend('webgl');
                    status.innerText = "LIGANDO C√ÇMERA...";
                    
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } },
                        audio: false
                    });
                    Motion.video.srcObject = stream;
                    await new Promise(r => Motion.video.onloadedmetadata = r);
                    Motion.video.play();

                    status.innerText = "CARREGANDO REDE NEURAL...";
                    const config = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING };
                    Motion.detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, config);
                    return true;
                } catch (e) {
                    console.warn(e);
                    document.getElementById('btn-force-start').classList.remove('hidden');
                    status.innerText = "ERRO: C√ÇMERA N√ÉO DETECTADA (HTTPS?)";
                    status.classList.add('text-red-500');
                    return false;
                }
            },

            update: async (w, h) => {
                if (!Motion.detector) return null;
                
                const now = performance.now();
                const dt = Math.min((now - Motion.lastTime)/1000, 0.1);
                Motion.lastTime = now;

                let poses = [];
                try { poses = await Motion.detector.estimatePoses(Motion.video); } catch (e) { return null; }

                if (poses.length === 0) {
                    App.setStatus(false, "CORPO N√ÉO DETECTADO");
                    return null; 
                }

                App.setStatus(true, "CONECTADO");

                const raw = poses[0].keypoints;
                const vw = Motion.video.videoWidth;
                const vh = Motion.video.videoHeight;
                
                // Scale Cover
                const scale = Math.max(w / vw, h / vh);
                const ox = (w - (vw * scale)) / 2;
                const oy = (h - (vh * scale)) / 2;

                // CORRE√á√ÉO DE ESPELHO
                const map = (kp) => ({
                    x: w - (((vw - kp.x) * scale) + ox), 
                    y: (kp.y * scale) + oy,
                    score: kp.score
                });

                const find = n => raw.find(k => k.name === n);
                
                const p = {
                    nose: map(find('nose')),
                    shoulders: { l: map(find('left_shoulder')), r: map(find('right_shoulder')) },
                    wrists: { l: map(find('left_wrist')), r: map(find('right_wrist')) },
                    dt: dt
                };

                // Largura do corpo (Refer√™ncia)
                p.width = Math.hypot(p.shoulders.l.x - p.shoulders.r.x, p.shoulders.l.y - p.shoulders.r.y) || 100;
                p.center = { x: (p.shoulders.l.x + p.shoulders.r.x)/2, y: (p.shoulders.l.y + p.shoulders.r.y)/2 };

                // Suaviza√ß√£o
                if (Motion.prevPose) {
                    const alpha = 0.5;
                    const lerp = (a, b) => a * alpha + b * (1-alpha);
                    p.center.x = lerp(p.center.x, Motion.prevPose.center.x);
                    p.center.y = lerp(p.center.y, Motion.prevPose.center.y);
                    p.wrists.l.x = lerp(p.wrists.l.x, Motion.prevPose.wrists.l.x);
                    p.wrists.l.y = lerp(p.wrists.l.y, Motion.prevPose.wrists.l.y);
                    p.wrists.r.x = lerp(p.wrists.r.x, Motion.prevPose.wrists.r.x);
                    p.wrists.r.y = lerp(p.wrists.r.y, Motion.prevPose.wrists.r.y);
                }
                
                Motion.prevPose = p;
                return p;
            }
        };

        /**
         * =========================================================================
         * 2. GRAPHICS ENGINE
         * =========================================================================
         */
        const Gfx = {
            canvas: document.getElementById('game-canvas'),
            ctx: null,
            width: 0, height: 0,

            init: () => {
                Gfx.ctx = Gfx.canvas.getContext('2d');
                window.addEventListener('resize', Gfx.resize);
                Gfx.resize();
            },

            resize: () => {
                Gfx.width = window.innerWidth;
                Gfx.height = window.innerHeight;
                Gfx.canvas.width = Gfx.width;
                Gfx.canvas.height = Gfx.height;
            },

            clear: () => Gfx.ctx.clearRect(0, 0, Gfx.width, Gfx.height),

            drawSkeleton: (pose, color) => {
                if (!pose) return;
                const ctx = Gfx.ctx;
                ctx.save();
                ctx.strokeStyle = color; ctx.lineWidth = 4; ctx.lineCap = 'round';
                ctx.shadowBlur = 15; ctx.shadowColor = color;
                
                const line = (p1, p2) => {
                    if (p1.score > 0.3 && p2.score > 0.3) {
                        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                    }
                };
                
                line(pose.shoulders.l, pose.shoulders.r);
                line(pose.shoulders.l, pose.wrists.l); // Simplificado: Ombro -> Pulso
                line(pose.shoulders.r, pose.wrists.r);
                
                if (pose.nose.score > 0.3) {
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(pose.nose.x, pose.nose.y, 10, 0, Math.PI*2); ctx.fill();
                }
                ctx.restore();
            },

            drawWheel: (angle, active, w, h) => {
                const ctx = Gfx.ctx;
                const cx = w/2; const cy = 150;
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(angle);
                
                ctx.beginPath(); ctx.arc(0,0, 60, 0, Math.PI*2);
                ctx.lineWidth = 10; 
                ctx.strokeStyle = active ? '#00F3FF' : 'rgba(255,255,255,0.2)';
                ctx.stroke();
                
                // Detalhe
                ctx.beginPath(); ctx.moveTo(-60, 0); ctx.lineTo(60, 0); 
                ctx.lineWidth = 6; ctx.stroke();
                
                ctx.restore();
            }
        };

        /**
         * =========================================================================
         * JOGO 1: KART
         * =========================================================================
         */
        class GameKart {
            constructor() {
                this.speed = 0;
                this.angle = 0;
                this.carX = 0;
                this.score = 0;
                this.curve = 0;
                this.obstacles = [];
                this.handsActive = false;
                App.msg("LEVANTE AS M√ÉOS!", "#00F3FF");
            }

            update(pose, ctx, w, h) {
                // VOLANTE
                let targetAngle = 0;
                this.handsActive = false;

                if (pose && pose.wrists.l.score > 0.3 && pose.wrists.r.score > 0.3) {
                    // M√£os na metade superior?
                    if (pose.wrists.l.y < h * 0.7) {
                        this.handsActive = true;
                        const dy = pose.wrists.r.y - pose.wrists.l.y;
                        const dx = pose.wrists.r.x - pose.wrists.l.x;
                        let raw = Math.atan2(dy, dx);
                        
                        // Clamp
                        raw = Math.max(-1.0, Math.min(1.0, raw));
                        targetAngle = raw;
                        
                        this.speed = Math.min(150, this.speed + 80 * pose.dt);
                    }
                }

                if (!this.handsActive) {
                    this.speed *= 0.95;
                    targetAngle = 0;
                }

                this.angle += (targetAngle - this.angle) * 5 * pose.dt;

                // F√çSICA
                this.curve = Math.sin(Date.now() / 2000) * 0.6;
                this.carX += (this.angle * 3.0 - (this.curve * this.speed/100)) * pose.dt;
                
                if (this.carX < -1.5) this.carX = -1.5;
                if (this.carX > 1.5) this.carX = 1.5;

                this.score += Math.floor(this.speed * pose.dt);

                // OBST√ÅCULOS
                if (Math.random() < 0.02 && this.speed > 30) this.obstacles.push({x: (Math.random()-0.5)*2.5, z: 0});

                // RENDER
                ctx.clearRect(0,0,w,h);
                const hz = h * 0.4;
                
                // Estrada
                ctx.fillStyle = '#111';
                ctx.beginPath();
                const cTop = w/2 + (this.curve * 200);
                const cBot = w/2 + (this.carX * -300);
                ctx.moveTo(cTop-10, hz); ctx.lineTo(cTop+10, hz);
                ctx.lineTo(cBot+w*1.5, h); ctx.lineTo(cBot-w*1.5, h);
                ctx.fill();
                
                // Bordas Neon
                ctx.strokeStyle = '#00F3FF'; ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(cTop-10, hz); ctx.lineTo(cBot-w*1.5, h);
                ctx.moveTo(cTop+10, hz); ctx.lineTo(cBot+w*1.5, h);
                ctx.stroke();

                // Obst√°culos
                this.obstacles.forEach((obs, i) => {
                    obs.z += (this.speed * 0.002) * pose.dt * 60;
                    if (obs.z > 1.2) { this.obstacles.splice(i, 1); return; }
                    
                    const drawY = hz + (obs.z * (h - hz));
                    const roadX = cTop + (cBot - cTop) * obs.z;
                    const drawX = roadX + (obs.x * w * 0.5 * obs.z);
                    const size = 50 * obs.z * obs.z;

                    ctx.fillStyle = '#FF0055';
                    ctx.shadowBlur = 10; ctx.shadowColor = '#FF0055';
                    ctx.fillRect(drawX - size/2, drawY - size, size, size);
                    ctx.shadowBlur = 0;

                    if (obs.z > 0.9 && obs.z < 1.0 && Math.abs(drawX - w/2) < 80) {
                        this.speed = 10;
                        App.msg("BATIDA!", "red");
                        ctx.fillStyle = 'white'; ctx.fillRect(0,0,w,h);
                    }
                });

                // Carro
                ctx.save();
                ctx.translate(w/2, h - 150);
                ctx.rotate(this.angle * 0.3);
                ctx.fillStyle = '#00F3FF';
                ctx.beginPath(); ctx.roundRect(-50, -30, 100, 60, 10); ctx.fill();
                ctx.restore();

                // HUD
                Gfx.drawSteeringWheel(this.angle, this.handsActive, w, h);
                Gfx.drawSkeleton(pose, this.handsActive ? '#00F3FF' : '#555');

                return this.score;
            }
        }

        /**
         * =========================================================================
         * JOGO 2: STREET RUN
         * =========================================================================
         */
        class GameRun {
            constructor() {
                this.score = 0;
                this.speed = 0;
                this.lane = 0;
                this.playerY = 0;
                this.jumpVel = 0;
                this.obstacles = [];
                this.lastY = 0;
                App.msg("CORRA!", "#00FF9D");
            }

            update(pose, ctx, w, h) {
                // INPUT
                if (pose && pose.shoulders.l.score > 0.3) {
                    const midX = pose.center.x;
                    const midY = pose.center.y;

                    // Dire√ß√£o
                    const diffX = midX - (w/2);
                    if (diffX < -w*0.15) this.lane = -1;
                    else if (diffX > w*0.15) this.lane = 1;
                    else this.lane = 0;

                    // Corrida (Oscila√ß√£o Vertical)
                    if (!this.lastY) this.lastY = midY;
                    const delta = Math.abs(midY - this.lastY);
                    this.lastY = midY;
                    
                    if (delta/pose.width > 0.02) this.speed = Math.min(100, this.speed + 150*pose.dt);
                    else this.speed = Math.max(0, this.speed - 50*pose.dt);

                    // Pulo
                    if (this.playerY === 0 && pose.wrists.l.y < pose.nose.y) {
                        this.jumpVel = 20; this.playerY = 1; App.msg("PULO!", "#00FF9D");
                    }
                }

                // F√≠sica Pulo
                if (this.playerY > 0) {
                    this.playerY += this.jumpVel * pose.dt * 2;
                    this.jumpVel -= 60 * pose.dt;
                    if (this.playerY <= 0) { this.playerY = 0; this.jumpVel = 0; }
                }

                this.score += Math.floor(this.speed * pose.dt);

                // Render
                ctx.clearRect(0,0,w,h);
                const hz = h * 0.4;
                
                // Ch√£o
                ctx.fillStyle = '#111'; ctx.beginPath(); ctx.moveTo(w/2, hz); ctx.lineTo(w*2, h); ctx.lineTo(-w, h); ctx.fill();
                
                // Grid
                ctx.strokeStyle = '#00FF9D'; ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(w/2, hz); ctx.lineTo(w*0.2, h);
                ctx.moveTo(w/2, hz); ctx.lineTo(w*0.5, h);
                ctx.moveTo(w/2, hz); ctx.lineTo(w*0.8, h);
                ctx.stroke();

                // Obst√°culos
                if (Math.random() < 0.02 && this.speed > 10) this.obstacles.push({lane: Math.floor(Math.random()*3)-1, z:0});
                
                this.obstacles.forEach((obs, i) => {
                    obs.z += (this.speed * 0.005 + 0.01) * 60 * pose.dt;
                    if (obs.z > 1.2) { this.obstacles.splice(i,1); return; }

                    const drawY = hz + (obs.z * (h-hz));
                    const drawX = (w/2) + (obs.lane * w * 2 * obs.z * 0.15);
                    const size = 60 * obs.z;

                    ctx.fillStyle = '#FF9900';
                    ctx.shadowBlur = 10; ctx.shadowColor = '#FF9900';
                    ctx.fillRect(drawX - size/2, drawY - size, size, size);
                    ctx.shadowBlur = 0;

                    // Colis√£o
                    if (obs.z > 0.9 && obs.z < 1.0 && obs.lane === this.lane && this.playerY === 0) {
                        this.speed = 0; 
                        App.msg("CRASH!", "red");
                        ctx.fillStyle = 'white'; ctx.fillRect(0,0,w,h);
                        this.obstacles.splice(i,1);
                    }
                });

                // Avatar
                ctx.save();
                ctx.translate(this.lane * 100, this.playerY * -200);
                Gfx.drawSkeleton(pose, '#00FF9D');
                ctx.restore();

                return this.score;
            }
        }

        /**
         * =========================================================================
         * JOGO 3: RHYTHM BOX
         * =========================================================================
         */
        class GameBox {
            constructor() {
                this.score = 0;
                this.targets = [];
                this.timer = 0;
                this.beatInterval = 0.8;
                App.msg("FIGHT!", "#FF0055");
            }

            update(pose, ctx, w, h) {
                // Spawn
                this.timer += pose.dt;
                if (this.timer > this.beatInterval) {
                    this.timer = 0;
                    const side = Math.random() > 0.5 ? 'L' : 'R';
                    this.targets.push({
                        x: side === 'L' ? w*0.2 : w*0.8,
                        y: h*0.3 + Math.random() * h*0.3,
                        r: 10, active: true, side: side,
                        color: side === 'L' ? '#00F3FF' : '#FF0055'
                    });
                }

                ctx.clearRect(0,0,w,h);
                Gfx.drawSkeleton(pose, '#555');

                this.targets.forEach(t => {
                    if (!t.active) return;
                    t.r += 80 * pose.dt;

                    // Desenha
                    ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2);
                    ctx.strokeStyle = t.color; ctx.lineWidth = 4; ctx.stroke();
                    ctx.fillStyle = t.color + '44'; ctx.fill();

                    // Hit
                    if (pose && t.r > 40 && !t.hit) {
                        const hand = (t.side === 'L') ? pose.wrists.l : pose.wrists.r;
                        const dist = Math.hypot(hand.x - t.x, hand.y - t.y);
                        
                        // Hitbox aumentada
                        if (dist < t.r + 50) {
                            t.active = false; t.hit = true;
                            this.score += 100;
                            App.msg("HIT!", t.color);
                            // FX
                            ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(t.x, t.y, 80, 0, Math.PI*2); ctx.fill();
                        }
                    }

                    if (t.r > 100) { t.active = false; App.msg("MISS", "#555"); }
                });

                this.targets = this.targets.filter(t => t.active);
                return this.score;
            }
        }

        /**
         * =========================================================================
         * APP MAIN
         * =========================================================================
         */
        const App = {
            game: null,
            loopId: null,

            init: async () => {
                Gfx.init();
                const ready = await Motion.init();
                if (ready) {
                    document.getElementById('screen-load').classList.add('hidden');
                    document.getElementById('screen-menu').classList.remove('hidden');
                    document.getElementById('screen-menu').classList.add('flex');
                }
            },

            // Fun√ß√£o de fallback para testar sem c√¢mera se necess√°rio
            forceStart: () => {
                document.getElementById('screen-load').classList.add('hidden');
                document.getElementById('screen-menu').classList.remove('hidden');
                document.getElementById('screen-menu').classList.add('flex');
            },

            launch: (type) => {
                document.getElementById('screen-menu').classList.remove('flex');
                document.getElementById('screen-menu').classList.add('hidden');
                document.getElementById('screen-hud').classList.remove('hidden');
                document.getElementById('screen-hud').classList.add('flex');
                document.getElementById('screen-gameover').classList.add('hidden');

                if (type === 'kart') App.game = new GameKart();
                if (type === 'run') App.game = new GameRun();
                if (type === 'box') App.game = new GameBox();

                App.loop();
            },

            stop: () => {
                cancelAnimationFrame(App.loopId);
                App.game = null;
                document.getElementById('screen-hud').classList.add('hidden');
                document.getElementById('screen-menu').classList.remove('hidden');
                document.getElementById('screen-menu').classList.add('flex');
                Gfx.clear();
            },

            msg: (text, color) => {
                const el = document.getElementById('msg-text');
                el.innerText = text; el.style.color = color;
                el.style.opacity = 1; el.style.transform = "scale(1.5)";
                setTimeout(() => { el.style.opacity = 0; el.style.transform = "scale(1)"; }, 400);
            },

            setStatus: (ok, text) => {
                const dot = document.getElementById('status-dot');
                const txt = document.getElementById('hud-status');
                dot.style.backgroundColor = ok ? '#00FF9D' : '#FF0055';
                txt.innerText = text;
            },

            loop: async () => {
                if (!App.game) return;
                
                // Sempre tenta atualizar o pose, mas n√£o trava o jogo se falhar
                const pose = await Motion.update(Gfx.width, Gfx.height);
                
                // Se o jogo precisa de pose para l√≥gica interna, passa. Se n√£o tiver pose,
                // passa null e o jogo deve lidar (ex: pausar ou desacelerar)
                const score = App.game.update(pose, Gfx.ctx, Gfx.width, Gfx.height);
                document.getElementById('hud-score').innerText = score;

                App.loopId = requestAnimationFrame(App.loop);
            }
        };

        window.onload = App.init;

    </script>
</body>
</html>