<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>thIAguinho Wii: Vertical Edition</title>
    
    <!-- TENSORFLOW.JS (IA Core) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <!-- TAILWIND CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- FONTS -->
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;700;900&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary: #00C3FF;
            --secondary: #FF0055;
            --glass: rgba(255, 255, 255, 0.15);
            --bg-dark: #0f172a;
        }

        body {
            background-color: var(--bg-dark);
            font-family: 'Nunito', sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            color: white;
            margin: 0;
        }

        /* LAYOUT & CAMADAS */
        #viewport { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
        
        #video-feed {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scaleX(-1); /* Espelho */
            min-width: 100%; min-height: 100%;
            width: auto; height: auto;
            object-fit: cover;
            opacity: 0.15; /* Sutil para imers√£o */
            z-index: 0;
        }

        #game-canvas { position: absolute; inset: 0; z-index: 10; width: 100%; height: 100%; }

        #ui-layer { 
            position: absolute; inset: 0; z-index: 20; pointer-events: none; 
            padding: env(safe-area-inset-top) 20px 40px 20px;
            display: flex; flex-direction: column;
        }
        .interactive { pointer-events: auto; }

        /* CARDS DO MENU */
        .game-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 24px;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            position: relative; overflow: hidden;
        }
        .game-card:active { transform: scale(0.96); background: rgba(255, 255, 255, 0.1); }
        
        .card-icon { font-size: 3.5rem; margin-bottom: 0.5rem; filter: drop-shadow(0 0 10px rgba(255,255,255,0.3)); }

        /* LOGO ESTILIZADO */
        .brand-logo { font-weight: 900; letter-spacing: -1px; }
        .brand-ia { color: var(--primary); font-size: 1.1em; }

        /* LOADERS & HUD */
        .loader {
            width: 40px; height: 40px; border: 4px solid #FFF;
            border-bottom-color: var(--primary); border-radius: 50%;
            animation: rotation 1s linear infinite;
        }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .hud-pill {
            background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.2);
            border-radius: 99px; padding: 8px 24px;
            display: flex; flex-direction: column; align-items: center;
        }

        /* ANIMA√á√ïES */
        @keyframes float { 0%,100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        .anim-float { animation: float 3s ease-in-out infinite; }
        
        .pulse-text { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.5; } }
    </style>
</head>
<body>

    <div id="viewport">
        <!-- V√çDEO (FUNDO) -->
        <video id="video-feed" autoplay muted playsinline></video>
        <!-- RENDERIZA√á√ÉO DO JOGO -->
        <canvas id="game-canvas"></canvas>

        <!-- INTERFACE DE USU√ÅRIO -->
        <div id="ui-layer">
            
            <!-- TELA DE LOADING -->
            <div id="screen-load" class="absolute inset-0 bg-slate-900 z-50 flex flex-col items-center justify-center interactive">
                <div class="loader mb-6"></div>
                <h1 class="text-3xl text-white brand-logo">th<span class="brand-ia">IA</span>guinho</h1>
                <p class="text-slate-400 text-xs mt-2 uppercase tracking-[0.3em]">Carregando IA...</p>
                <div id="debug-log" class="text-[10px] text-slate-600 mt-4 h-4"></div>
            </div>

            <!-- MENU PRINCIPAL -->
            <div id="screen-menu" class="hidden absolute inset-0 bg-slate-900/80 backdrop-blur-md z-40 flex flex-col items-center justify-center interactive p-6">
                
                <div class="mb-10 text-center anim-float">
                    <h1 class="text-6xl text-white brand-logo leading-none drop-shadow-2xl">
                        th<span class="brand-ia">IA</span>guinho
                    </h1>
                    <div class="mt-2 inline-block bg-gradient-to-r from-cyan-500 to-blue-600 text-white text-[10px] font-bold px-3 py-1 rounded-full uppercase tracking-widest shadow-lg">
                        Wii Mobile Edition
                    </div>
                </div>

                <div class="grid grid-cols-1 gap-4 w-full max-w-sm">
                    <!-- KART -->
                    <div onclick="App.launch('kart')" class="game-card flex items-center p-4 cursor-pointer group">
                        <div class="card-icon mr-4">üèéÔ∏è</div>
                        <div class="flex-1">
                            <h2 class="text-2xl font-bold text-white group-hover:text-cyan-400 transition-colors">Super Kart</h2>
                            <p class="text-xs text-slate-300">Volante Virtual & Obst√°culos</p>
                        </div>
                        <div class="text-2xl text-slate-500">‚Ä∫</div>
                    </div>

                    <!-- RUN -->
                    <div onclick="App.launch('run')" class="game-card flex items-center p-4 cursor-pointer group">
                        <div class="card-icon mr-4">üèÉ</div>
                        <div class="flex-1">
                            <h2 class="text-2xl font-bold text-white group-hover:text-green-400 transition-colors">Street Run</h2>
                            <p class="text-xs text-slate-300">Corra e Pule na Frente da C√¢mera</p>
                        </div>
                        <div class="text-2xl text-slate-500">‚Ä∫</div>
                    </div>

                    <!-- BOXE -->
                    <div onclick="App.launch('beat')" class="game-card flex items-center p-4 cursor-pointer group">
                        <div class="card-icon mr-4">ü•ä</div>
                        <div class="flex-1">
                            <h2 class="text-2xl font-bold text-white group-hover:text-pink-400 transition-colors">Rhythm Box</h2>
                            <p class="text-xs text-slate-300">Treino de Academia Musical</p>
                        </div>
                        <div class="text-2xl text-slate-500">‚Ä∫</div>
                    </div>
                </div>
                
                <p class="text-slate-500 text-[10px] mt-8 text-center max-w-xs">
                    Posicione o celular em um local est√°vel. Afaste-se 1.5m para que a c√¢mera veja seus bra√ßos.
                </p>
            </div>

            <!-- HUD (IN-GAME) -->
            <div id="screen-hud" class="hidden w-full h-full flex flex-col justify-between pointer-events-none">
                <!-- Top Bar -->
                <div class="flex justify-between items-start w-full pt-4">
                    <div class="hud-pill">
                        <span class="text-[9px] text-cyan-200 font-bold uppercase tracking-widest">SCORE</span>
                        <span id="hud-score" class="text-2xl font-black text-white leading-none">0</span>
                    </div>
                    
                    <button onclick="App.stop()" class="interactive w-10 h-10 rounded-full bg-white/10 backdrop-blur border border-white/20 text-red-400 font-bold flex items-center justify-center active:bg-white/20 transition-all shadow-lg">
                        ‚úï
                    </button>
                </div>
                
                <!-- Feedback Area (Center) -->
                <div id="hud-msg" class="absolute inset-0 flex items-center justify-center text-5xl font-black text-white drop-shadow-[0_4px_0_rgba(0,0,0,0.5)] opacity-0 transition-opacity duration-150 text-center" style="-webkit-text-stroke: 1px black;">
                </div>

                <!-- Bottom Stats -->
                <div class="w-full flex justify-center pb-8">
                    <div id="hud-gauge-container" class="hidden hud-pill w-48">
                        <span class="text-[9px] text-gray-300 uppercase mb-1">VELOCIDADE</span>
                        <div class="w-full h-2 bg-gray-700 rounded-full overflow-hidden">
                            <div id="hud-gauge-fill" class="h-full bg-gradient-to-r from-green-400 to-cyan-400 w-0 transition-all duration-200"></div>
                        </div>
                        <span id="hud-speed-val" class="text-xs font-bold mt-1">0 km/h</span>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
        /**
         * =========================================================================
         * 1. MOTOR GR√ÅFICO (RENDERIZA√á√ÉO)
         * =========================================================================
         */
        const Gfx = {
            canvas: document.getElementById('game-canvas'),
            ctx: null,
            width: 0, height: 0,

            init: () => {
                Gfx.ctx = Gfx.canvas.getContext('2d');
                window.addEventListener('resize', Gfx.resize);
                Gfx.resize();
            },

            resize: () => {
                const dpr = window.devicePixelRatio || 1;
                Gfx.width = window.innerWidth;
                Gfx.height = window.innerHeight;
                
                Gfx.canvas.width = Gfx.width * dpr;
                Gfx.canvas.height = Gfx.height * dpr;
                
                Gfx.ctx.scale(dpr, dpr);
            },

            // Desenhar Volante Virtual (Guia)
            drawSteeringWheel: (angle) => {
                const cx = Gfx.width / 2;
                const cy = 150; // Posi√ß√£o SUPERIOR como solicitado
                const r = 80;

                const ctx = Gfx.ctx;
                ctx.save();
                ctx.translate(cx, cy);
                
                // Rota√ß√£o visual baseada na entrada do usu√°rio
                ctx.rotate(angle);

                // Aro Externo
                ctx.beginPath(); ctx.arc(0,0, r, 0, Math.PI*2);
                ctx.lineWidth = 12; ctx.strokeStyle = 'rgba(255,255,255,0.8)'; ctx.stroke();
                
                // Detalhes internos
                ctx.beginPath(); ctx.moveTo(-r, 0); ctx.lineTo(r, 0);
                ctx.moveTo(0, 0); ctx.lineTo(0, r);
                ctx.lineWidth = 8; ctx.stroke();

                // Centro
                ctx.beginPath(); ctx.arc(0,0, 20, 0, Math.PI*2);
                ctx.fillStyle = '#00C3FF'; ctx.fill();

                ctx.restore();

                // Texto Guia
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                ctx.font = "bold 12px Nunito";
                ctx.textAlign = "center";
                ctx.fillText("SEGURE AQUI", cx, cy - r - 20);
            }
        };

        /**
         * =========================================================================
         * 2. MOTOR DE SENSORIAMENTO (MOVENET VERTICAL)
         * =========================================================================
         */
        const Motion = {
            detector: null,
            video: document.getElementById('video-feed'),
            prevPose: null,

            init: async () => {
                const log = (t) => document.getElementById('debug-log').innerText = t;
                try {
                    await tf.setBackend('webgl');
                    log("Acessando C√¢mera...");
                    
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } },
                        audio: false
                    });
                    Motion.video.srcObject = stream;
                    await new Promise(r => Motion.video.onloadedmetadata = r);
                    Motion.video.play();

                    log("Carregando Rede Neural...");
                    const config = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING };
                    Motion.detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, config);
                    return true;
                } catch (e) {
                    alert("Erro ao iniciar c√¢mera: " + e.message);
                    return false;
                }
            },

            getPose: async () => {
                if (!Motion.detector) return null;
                
                const poses = await Motion.detector.estimatePoses(Motion.video);
                if (poses.length === 0) return null;

                const raw = poses[0].keypoints;
                
                // Mapeamento "Cover" para Tela Vertical (Crucial para Mobile)
                const vw = 640; const vh = 480;
                const sw = Gfx.width; const sh = Gfx.height;
                
                // Calculo de escala para preencher a tela vertical (zoom in no centro do v√≠deo)
                const scale = Math.max(sw / vw, sh / vh);
                const ox = (sw - (vw * scale)) / 2;
                const oy = (sh - (vh * scale)) / 2;

                const map = (kp) => ({
                    x: ((vw - kp.x) * scale) + ox, // Inverte X (Espelho)
                    y: (kp.y * scale) + oy,
                    score: kp.score,
                    name: kp.name
                });

                // Suaviza√ß√£o (Lerp) para evitar tremedeira
                const smooth = (curr, prev) => prev ? (curr * 0.5 + prev * 0.5) : curr;

                const mapped = raw.map(map);
                const find = n => mapped.find(k => k.name === n);

                let p = {
                    nose: find('nose'),
                    wrists: { l: find('left_wrist'), r: find('right_wrist') },
                    shoulders: { l: find('left_shoulder'), r: find('right_shoulder') }
                };

                if (Motion.prevPose) {
                    p.nose.x = smooth(p.nose.x, Motion.prevPose.nose.x);
                    p.nose.y = smooth(p.nose.y, Motion.prevPose.nose.y);
                    // Suaviza pulsos para dire√ß√£o precisa
                    p.wrists.l.x = smooth(p.wrists.l.x, Motion.prevPose.wrists.l.x);
                    p.wrists.r.x = smooth(p.wrists.r.x, Motion.prevPose.wrists.r.x);
                    p.wrists.l.y = smooth(p.wrists.l.y, Motion.prevPose.wrists.l.y);
                    p.wrists.r.y = smooth(p.wrists.r.y, Motion.prevPose.wrists.r.y);
                }
                Motion.prevPose = p;
                return p;
            }
        };

        /**
         * =========================================================================
         * JOGO 1: SUPER KART (VOLANTE VIRTUAL)
         * =========================================================================
         */
        class GameKart {
            constructor() {
                this.score = 0;
                this.speed = 0;
                this.angle = 0;
                this.carX = 0; // Posi√ß√£o lateral (-1 a 1)
                this.roadCurve = 0;
                this.obstacles = [];
                this.frameCount = 0;
                
                document.getElementById('hud-gauge-container').classList.remove('hidden');
                App.msg("SEGURE O VOLANTE ACIMA!");
            }

            update(pose, ctx, w, h) {
                // 1. C√ÅLCULO DE DIRE√á√ÉO (VOLANTE)
                // O usu√°rio deve levantar as m√£os para a parte superior (y < h/2)
                if (pose && pose.wrists.l.y < h*0.6 && pose.wrists.r.y < h*0.6) {
                    const dx = pose.wrists.r.x - pose.wrists.l.x;
                    const dy = pose.wrists.r.y - pose.wrists.l.y;
                    this.angle = Math.atan2(dy, dx);
                    
                    // Acelerar se as m√£os estiverem na posi√ß√£o correta
                    if (this.speed < 120) this.speed += 1;
                } else {
                    // Desacelerar se baixar os bra√ßos
                    this.speed *= 0.95;
                    this.angle *= 0.9;
                }

                // F√≠sica do Carro
                this.carX += this.angle * (this.speed / 100);
                this.roadCurve = Math.sin(Date.now() / 2000) * 0.5; // Curva suave procedural
                this.carX -= this.roadCurve * (this.speed / 300); // Centr√≠fuga

                // Limites
                if (this.carX < -1.2) this.carX = -1.2;
                if (this.carX > 1.2) this.carX = 1.2;

                this.score += Math.floor(this.speed / 10);

                // Obst√°culos
                this.frameCount++;
                if (this.frameCount % 100 === 0 && this.speed > 50) {
                    this.obstacles.push({ x: (Math.random()-0.5)*2, z: 0 });
                }

                // 2. RENDERIZA√á√ÉO VERTICAL
                ctx.clearRect(0,0,w,h);
                
                const horizonY = h * 0.4;
                const roadTopW = 20;
                const roadBotW = w * 1.5;

                // Fundo
                const grad = ctx.createLinearGradient(0,0,0,h);
                grad.addColorStop(0, '#0f172a'); grad.addColorStop(0.4, '#1e293b'); grad.addColorStop(1, '#334155');
                ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);

                // Pista
                ctx.fillStyle = '#475569';
                ctx.beginPath();
                ctx.moveTo(w/2 + (this.roadCurve * 100) - roadTopW, horizonY);
                ctx.lineTo(w/2 + (this.roadCurve * 100) + roadTopW, horizonY);
                ctx.lineTo(w/2 + roadBotW + (this.carX * -200), h); // Move a base da estrada para simular movimento lateral
                ctx.lineTo(w/2 - roadBotW + (this.carX * -200), h);
                ctx.fill();

                // Obst√°culos
                this.obstacles.forEach((obs, i) => {
                    obs.z += this.speed * 0.001;
                    if (obs.z > 1) { this.obstacles.splice(i,1); return; }

                    const scale = obs.z * obs.z; // Perspectiva n√£o-linear
                    const drawY = horizonY + (obs.z * (h - horizonY));
                    // X deve seguir a curva e o deslocamento do carro
                    const roadXAtZ = (w/2) + (this.roadCurve * 100 * (1-obs.z)) - (this.carX * 200 * obs.z);
                    const drawX = roadXAtZ + (obs.x * w * obs.z); 
                    const size = 20 + (80 * scale);

                    ctx.fillStyle = '#ef4444';
                    ctx.fillRect(drawX - size/2, drawY - size, size, size);

                    // Colis√£o simples
                    if (obs.z > 0.8 && obs.z < 0.95 && Math.abs(drawX - w/2) < 60) {
                        this.speed = 10;
                        App.msg("CRASH!", "#ff0000");
                        ctx.fillStyle = 'white'; ctx.fillRect(0,0,w,h);
                    }
                });

                // Carro do Jogador (Fixo embaixo)
                const cx = w/2;
                const cy = h - 100;
                
                // Sombra e Corpo
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.ellipse(cx, cy+20, 60, 15, 0,0,Math.PI*2); ctx.fill();
                ctx.fillStyle = '#00C3FF'; 
                // Desenho simples de traseira de carro esportivo
                ctx.beginPath(); 
                ctx.roundRect(cx-50, cy-30, 100, 50, 10);
                ctx.fill();
                ctx.fillStyle = '#1e293b'; ctx.fillRect(cx-40, cy-40, 80, 20); // Vidro
                ctx.fillStyle = '#ef4444'; ctx.fillRect(cx-45, cy-10, 20, 10); ctx.fillRect(cx+25, cy-10, 20, 10); // Luzes

                // DESENHAR O VOLANTE GUIA (Visual Guide)
                Gfx.drawSteeringWheel(this.angle);

                // Feedback das m√£os na tela
                if (pose) {
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath(); ctx.arc(pose.wrists.l.x, pose.wrists.l.y, 10, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(pose.wrists.r.x, pose.wrists.r.y, 10, 0, Math.PI*2); ctx.fill();
                }

                // UI Update
                document.getElementById('hud-speed-val').innerText = Math.floor(this.speed) + " km/h";
                document.getElementById('hud-gauge-fill').style.width = Math.min(100, this.speed) + "%";

                return this.score;
            }
        }

        /**
         * =========================================================================
         * JOGO 2: STREET RUN (CORRIDA NO LUGAR)
         * =========================================================================
         */
        class GameRun {
            constructor() {
                this.score = 0;
                this.speed = 0; // 0 a 50
                this.lane = 0; // -1, 0, 1
                this.distance = 0;
                this.playerY = 0;
                this.prevNoseY = 0;
                this.obstacles = [];
                
                document.getElementById('hud-gauge-container').classList.remove('hidden');
                App.msg("CORRA NO LUGAR!");
            }

            update(pose, ctx, w, h) {
                // 1. INPUT
                if (pose && pose.nose.score > 0.4) {
                    // Detectar Corrida (Oscila√ß√£o Vertical do Nariz)
                    const delta = Math.abs(pose.nose.y - this.prevNoseY);
                    this.prevNoseY = pose.nose.y;

                    // Se oscilar muito, ganha velocidade. Se parar, perde.
                    if (delta > 2) {
                        this.speed += delta * 0.2; // Acelera√ß√£o
                    }
                    
                    // Dire√ß√£o (Posi√ß√£o X do nariz na tela)
                    const nx = pose.nose.x;
                    if (nx < w * 0.35) this.lane = -1;
                    else if (nx > w * 0.65) this.lane = 1;
                    else this.lane = 0;
                }

                // Atrito natural (Se parar de pular, para de correr)
                this.speed *= 0.95; 
                if (this.speed > 60) this.speed = 60;
                
                this.distance += this.speed;
                this.score = Math.floor(this.distance / 10);

                // Obst√°culos
                if (Math.random() < 0.02 && this.speed > 10) {
                    this.obstacles.push({ lane: Math.floor(Math.random()*3)-1, z: 0 });
                }

                // 2. RENDERIZA√á√ÉO
                ctx.clearRect(0,0,w,h);
                
                // Ch√£o listrado
                const offset = (this.distance % 100) / 100;
                const horizon = h * 0.4;
                
                ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,w,h); // Fundo
                
                // Desenhar 3 Pistas (Perspectiva)
                ctx.strokeStyle = '#334155';
                ctx.lineWidth = 2;
                
                const lanesX = [w*0.2, w*0.5, w*0.8]; // Topo (Horizonte)
                const lanesXBot = [-w*0.5, w*0.5, w*1.5]; // Base
                
                for(let i=0; i<3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(w/2, horizon); 
                    ctx.lineTo(lanesXBot[i], h);
                    ctx.stroke();
                }

                // Obst√°culos
                this.obstacles.forEach((obs, i) => {
                    obs.z += this.speed * 0.001 + 0.01;
                    if (obs.z > 1) { this.obstacles.splice(i,1); return; }

                    const py = horizon + (obs.z * (h - horizon));
                    // Interpola√ß√£o da pista
                    const laneWidthAtZ = (w * 2) * obs.z; // Largura aparente
                    const px = (w/2) + (obs.lane * (laneWidthAtZ * 0.3)); 
                    const size = 30 + (100 * obs.z);

                    ctx.fillStyle = '#f59e0b'; // Laranja warning
                    ctx.fillRect(px - size/2, py - size, size, size);

                    // Colis√£o
                    if (obs.z > 0.8 && obs.z < 0.95 && obs.lane === this.lane) {
                        this.speed = 0;
                        App.msg("BATIDA!", "#f59e0b");
                        ctx.fillStyle = 'white'; ctx.fillRect(0,0,w,h);
                    }
                });

                // Personagem (Corredor)
                const bob = Math.sin(Date.now() / 100) * (this.speed / 3);
                // Interpola√ß√£o suave de posi√ß√£o X
                const targetPx = (w/2) + (this.lane * (w * 0.25));
                this.playerY += (targetPx - this.playerY) * 0.1; // Smooth move
                const px = this.playerY || w/2;
                const py = h - 150 - bob;

                // Desenho do "Hominho"
                ctx.fillStyle = '#22c55e'; // Verde
                ctx.beginPath(); ctx.arc(px, py - 30, 20, 0, Math.PI*2); ctx.fill(); // Cabe√ßa
                ctx.fillRect(px - 15, py, 30, 50); // Corpo
                
                // Bra√ßos animados
                const armO = Math.sin(Date.now() / 100 * this.speed/10) * 20;
                ctx.strokeStyle = '#22c55e'; ctx.lineWidth = 8;
                ctx.beginPath(); ctx.moveTo(px-15, py+10); ctx.lineTo(px-30, py+30+armO); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(px+15, py+10); ctx.lineTo(px+30, py+30-armO); ctx.stroke();

                document.getElementById('hud-speed-val').innerText = Math.floor(this.speed) + " km/h";
                document.getElementById('hud-gauge-fill').style.width = Math.min(100, (this.speed/60)*100) + "%";

                return this.score;
            }
        }

        /**
         * =========================================================================
         * JOGO 3: RHYTHM BOX (ACADEMIA DE BOXE)
         * =========================================================================
         */
        class GameBeat {
            constructor() {
                this.score = 0;
                this.combo = 0;
                this.targets = []; // Bolhas
                this.timer = 0;
                this.beatInterval = 60; // Frames entre beats
                document.getElementById('hud-gauge-container').classList.add('hidden');
                App.msg("BOXE NO RITMO!");
            }

            update(pose, ctx, w, h) {
                // 1. SPAWN (Gerar bolhas no ritmo)
                this.timer++;
                if (this.timer % this.beatInterval === 0) {
                    const side = Math.random() > 0.5 ? 'L' : 'R';
                    this.targets.push({
                        id: Math.random(),
                        x: side === 'L' ? w * 0.25 : w * 0.75, // Esquerda ou Direita
                        y: Math.random() > 0.5 ? h * 0.3 : h * 0.6, // Alto ou Baixo
                        radius: 1, // Come√ßa pequena
                        maxRadius: 70,
                        active: true,
                        color: side === 'L' ? '#00C3FF' : '#FF0055' // Azul (Esq) / Rosa (Dir)
                    });
                    // Aumenta dificuldade com o tempo
                    if (this.beatInterval > 30) this.beatInterval -= 0.5;
                }

                // 2. L√ìGICA E RENDER
                ctx.clearRect(0,0,w,h);

                // Desenhar Alvos
                this.targets.forEach(t => {
                    if (!t.active) return;
                    
                    // Crescer bolha (efeito de aproxima√ß√£o)
                    t.radius += 1.5; 
                    
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.radius, 0, Math.PI*2);
                    ctx.fillStyle = t.color + '88'; // Semi-transparente
                    ctx.fill();
                    ctx.lineWidth = 4;
                    ctx.strokeStyle = 'white';
                    ctx.stroke();

                    // Feedback visual de "Hit Zone"
                    if (t.radius > 50 && t.radius < 70) {
                        ctx.beginPath(); ctx.arc(t.x, t.y, t.radius - 10, 0, Math.PI*2);
                        ctx.strokeStyle = '#ffff00'; ctx.stroke(); // Anel amarelo de "agora!"
                    }

                    // COLIS√ÉO (M√£o toca na bolha quando ela est√° grande)
                    if (pose && t.radius > 40) {
                        const hand = (t.color.includes('00C3FF')) ? pose.wrists.l : pose.wrists.r;
                        if (hand.score > 0.3) {
                            const dist = Math.hypot(hand.x - t.x, hand.y - t.y);
                            if (dist < t.radius + 20) {
                                // HIT!
                                t.active = false;
                                this.score += 100 + (this.combo * 10);
                                this.combo++;
                                App.msg(this.combo + "x COMBO!", t.color);
                                
                                // Part√≠culas de explos√£o
                                ctx.fillStyle = 'white';
                                ctx.beginPath(); ctx.arc(t.x, t.y, 90, 0, Math.PI*2); ctx.fill();
                            }
                        }
                    }

                    // Miss (Passou do tamanho m√°ximo)
                    if (t.radius > t.maxRadius) {
                        t.active = false;
                        this.combo = 0;
                        App.msg("MISS", "#94a3b8");
                    }
                });

                // Limpar mem√≥ria
                this.targets = this.targets.filter(t => t.active);

                // Desenhar Luvas do Jogador
                if (pose) {
                    const drawGlove = (kp, color) => {
                        if (kp.score > 0.3) {
                            ctx.beginPath();
                            ctx.arc(kp.x, kp.y, 40, 0, Math.PI*2);
                            ctx.fillStyle = color;
                            ctx.fill();
                            ctx.lineWidth = 4; ctx.strokeStyle = 'white'; ctx.stroke();
                            
                            // Brilho
                            ctx.shadowBlur = 20; ctx.shadowColor = color; ctx.stroke(); ctx.shadowBlur = 0;
                        }
                    };
                    drawGlove(pose.wrists.l, '#00C3FF');
                    drawGlove(pose.wrists.r, '#FF0055');
                }

                return this.score;
            }
        }

        /**
         * =========================================================================
         * 3. APP CONTROLLER (GERENCIADOR DE ESTADOS)
         * =========================================================================
         */
        const App = {
            game: null,
            loopId: null,

            init: async () => {
                Gfx.init();
                const ready = await Motion.init();
                
                if (ready) {
                    document.getElementById('screen-load').classList.add('hidden');
                    document.getElementById('screen-menu').classList.remove('hidden');
                    document.getElementById('screen-menu').classList.add('flex');
                }
            },

            launch: (type) => {
                document.getElementById('screen-menu').classList.remove('flex');
                document.getElementById('screen-menu').classList.add('hidden');
                document.getElementById('screen-hud').classList.remove('hidden');
                document.getElementById('screen-hud').classList.add('flex');

                if (type === 'kart') App.game = new GameKart();
                if (type === 'run') App.game = new GameRun();
                if (type === 'beat') App.game = new GameBeat();

                App.loop();
            },

            stop: () => {
                cancelAnimationFrame(App.loopId);
                App.game = null;
                document.getElementById('screen-hud').classList.add('hidden');
                document.getElementById('screen-menu').classList.remove('hidden');
                document.getElementById('screen-menu').classList.add('flex');
                Gfx.ctx.clearRect(0,0,Gfx.width, Gfx.height);
            },

            msg: (text, color='#fff') => {
                const el = document.getElementById('hud-msg');
                el.innerText = text;
                el.style.color = color;
                el.style.opacity = 1;
                el.style.transform = "scale(1.2)";
                setTimeout(() => {
                    el.style.opacity = 0;
                    el.style.transform = "scale(1)";
                }, 500);
            },

            loop: async () => {
                if (!App.game) return;

                const pose = await Motion.getPose();
                const score = App.game.update(pose, Gfx.ctx, Gfx.width, Gfx.height);
                
                document.getElementById('hud-score').innerText = score;
                App.loopId = requestAnimationFrame(App.loop);
            }
        };

        // INICIAR SISTEMA
        window.onload = App.init;

    </script>
</body>
</html>
