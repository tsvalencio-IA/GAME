<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <title>thIAguinho Wii: Ultimate</title>
    
    <!-- CORE: TENSORFLOW.JS -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <!-- UI: TAILWIND -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- FONTS -->
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700;900&display=swap" rel="stylesheet">

    <style>
        :root {
            --neon-cyan: #00F3FF;
            --neon-pink: #FF0055;
            --neon-lime: #CCFF00;
            --bg-dark: #050505;
        }

        body {
            background-color: var(--bg-dark);
            font-family: 'Rajdhani', sans-serif;
            margin: 0; padding: 0;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            width: 100vw; height: 100vh;
        }

        /* LAYOUT */
        #app-root { position: relative; width: 100%; height: 100%; overflow: hidden; }
        
        #video-feed {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scaleX(-1); /* Espelho Visual */
            min-width: 100%; min-height: 100%;
            width: auto; height: auto;
            object-fit: cover;
            opacity: 0.15; /* Visibilidade para refer√™ncia */
            z-index: 0;
            pointer-events: none;
        }

        #game-canvas { 
            position: absolute; inset: 0; z-index: 10; 
            width: 100%; height: 100%; 
        }

        #ui-layer { 
            position: absolute; inset: 0; z-index: 20; pointer-events: none; 
            display: flex; flex-direction: column; justify-content: space-between;
            padding: env(safe-area-inset-top) 20px 40px 20px;
        }
        .interactive { pointer-events: auto; }

        /* ESTILOS DE MENU E HUD */
        .glass-panel {
            background: rgba(10, 10, 15, 0.85);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .game-card {
            background: linear-gradient(180deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0.01) 100%);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative; overflow: hidden;
        }
        .game-card:active { transform: scale(0.96); border-color: var(--neon-cyan); }
        .game-card.kart { border-left: 4px solid var(--neon-cyan); }
        .game-card.run { border-left: 4px solid var(--neon-lime); }
        .game-card.beat { border-left: 4px solid var(--neon-pink); }

        .brand-text { letter-spacing: -1px; text-transform: uppercase; }
        .brand-ia { color: var(--neon-cyan); text-shadow: 0 0 15px var(--neon-cyan); }

        /* LOADING SPINNER */
        .spinner {
            width: 48px; height: 48px;
            border: 4px solid #333;
            border-top-color: var(--neon-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* DEBUG CONSOLE */
        #debug-log { 
            font-family: monospace; font-size: 10px; color: #666; 
            text-align: center; margin-top: 10px; 
        }
    </style>
</head>
<body>

    <div id="app-root">
        <video id="video-feed" autoplay muted playsinline></video>
        <canvas id="game-canvas"></canvas>

        <div id="ui-layer">
            
            <!-- TELA DE LOADING -->
            <div id="screen-load" class="absolute inset-0 bg-black z-50 flex flex-col items-center justify-center interactive">
                <div class="spinner mb-6"></div>
                <h1 class="text-4xl font-black text-white brand-text">th<span class="brand-ia">IA</span>guinho</h1>
                <p class="text-gray-500 text-xs font-bold tracking-[0.4em] mt-2">WII SYSTEM LOADING</p>
                <div id="debug-log">Inicializando IA...</div>
            </div>

            <!-- MENU PRINCIPAL -->
            <div id="screen-menu" class="hidden absolute inset-0 bg-black/90 backdrop-blur-md z-40 flex flex-col items-center justify-center interactive p-6">
                <div class="text-center mb-10 transform skew-x-[-5deg]">
                    <h1 class="text-6xl font-black text-white brand-text leading-none italic">
                        th<span class="brand-ia">IA</span>guinho
                    </h1>
                    <div class="mt-2 inline-block bg-white/10 px-4 py-1 rounded text-[10px] font-bold text-white tracking-widest border border-white/20">
                        WII ULTIMATE COLLECTION
                    </div>
                </div>

                <div class="grid grid-cols-1 gap-4 w-full max-w-sm">
                    <!-- KART -->
                    <div onclick="App.launch('kart')" class="game-card kart flex items-center p-4 cursor-pointer">
                        <div class="text-4xl mr-4 grayscale brightness-150">üèéÔ∏è</div>
                        <div class="flex-1">
                            <h2 class="text-xl font-bold text-white italic">TURBO KART</h2>
                            <p class="text-xs text-gray-400">Dire√ß√£o Real c/ Volante</p>
                        </div>
                        <div class="text-[10px] font-bold text-gray-500 border border-gray-600 px-2 py-1 rounded">PLAY</div>
                    </div>

                    <!-- RUN -->
                    <div onclick="App.launch('run')" class="game-card run flex items-center p-4 cursor-pointer">
                        <div class="text-4xl mr-4 grayscale brightness-150">üèÉ</div>
                        <div class="flex-1">
                            <h2 class="text-xl font-bold text-white italic">STREET RUN</h2>
                            <p class="text-xs text-gray-400">Corra e Pule no Lugar</p>
                        </div>
                        <div class="text-[10px] font-bold text-gray-500 border border-gray-600 px-2 py-1 rounded">PLAY</div>
                    </div>

                    <!-- BOXE -->
                    <div onclick="App.launch('beat')" class="game-card beat flex items-center p-4 cursor-pointer">
                        <div class="text-4xl mr-4 grayscale brightness-150">ü•ä</div>
                        <div class="flex-1">
                            <h2 class="text-xl font-bold text-white italic">RHYTHM BOX</h2>
                            <p class="text-xs text-gray-400">Soco R√≠tmico de Academia</p>
                        </div>
                        <div class="text-[10px] font-bold text-gray-500 border border-gray-600 px-2 py-1 rounded">PLAY</div>
                    </div>
                </div>
                
                <p class="text-gray-600 text-[10px] mt-8 max-w-xs text-center">
                    DICA: Posicione o celular em p√© e afaste-se 2 metros.
                </p>
            </div>

            <!-- HUD (DURANTE O JOGO) -->
            <div id="screen-hud" class="hidden w-full h-full flex flex-col justify-between pointer-events-none">
                <!-- Top Bar -->
                <div class="flex justify-between items-start w-full pt-2">
                    <div class="glass-panel px-6 py-2 flex flex-col items-center">
                        <span class="text-[9px] text-[var(--neon-cyan)] font-bold uppercase tracking-widest">SCORE</span>
                        <span id="hud-score" class="text-3xl font-black text-white leading-none font-mono">0</span>
                    </div>
                    
                    <button onclick="App.stop()" class="interactive w-10 h-10 rounded-full bg-white/10 backdrop-blur border border-white/20 text-red-500 font-bold flex items-center justify-center active:bg-white/20 transition-all shadow-lg">
                        ‚úï
                    </button>
                </div>
                
                <!-- Feedback Central (Mensagens Grandes) -->
                <div id="hud-msg" class="absolute inset-0 flex items-center justify-center text-5xl font-black text-white italic drop-shadow-[0_4px_0_rgba(0,0,0,1)] opacity-0 transition-opacity duration-150 text-center z-50 pointer-events-none" style="-webkit-text-stroke: 1px black;">
                </div>

                <!-- Bottom Stats -->
                <div class="w-full flex flex-col items-center gap-2 pb-4">
                    <div id="hud-gauge-wrap" class="hidden w-64 h-3 bg-gray-900 rounded-full overflow-hidden border border-gray-700">
                        <div id="hud-gauge-fill" class="h-full bg-gradient-to-r from-green-500 to-[var(--neon-cyan)] w-0 transition-all duration-100"></div>
                    </div>
                    <span id="hud-subtext" class="text-xs font-bold text-gray-400 bg-black/60 px-3 py-1 rounded-full uppercase backdrop-blur">READY</span>
                </div>
            </div>

        </div>
    </div>

    <script>
        /**
         * =========================================================================
         * 1. MOTION ENGINE (CORE) - MOTOR DE VIS√ÉO COMPUTACIONAL
         * Lida com a c√¢mera, TensorFlow, normaliza√ß√£o de coordenadas e f√≠sica.
         * =========================================================================
         */
        const Motion = {
            detector: null,
            video: document.getElementById('video-feed'),
            prevPose: null,
            lastFrameTime: 0,
            smoothing: 0.2, // EMA Smoothing Factor

            init: async () => {
                const log = (t) => {
                    const el = document.getElementById('debug-log');
                    if(el) el.innerText = t;
                    console.log(t);
                }
                
                try {
                    await tf.setBackend('webgl');
                    log("Acessando C√¢mera...");
                    
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } },
                        audio: false
                    });
                    Motion.video.srcObject = stream;
                    await new Promise(r => Motion.video.onloadedmetadata = r);
                    Motion.video.play();

                    log("Carregando Rede Neural...");
                    const config = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING };
                    Motion.detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, config);
                    return true;
                } catch (e) {
                    alert("ERRO DE C√ÇMERA: Certifique-se de usar HTTPS ou Localhost.\n" + e.message);
                    return false;
                }
            },

            // Processa um frame e retorna dados normalizados
            update: async (width, height) => {
                if (!Motion.detector) return null;
                
                const now = performance.now();
                const dt = Math.min((now - Motion.lastFrameTime) / 1000, 0.1); 
                Motion.lastFrameTime = now;

                let poses = null;
                try {
                    poses = await Motion.detector.estimatePoses(Motion.video);
                } catch(e) { return null; }

                if (!poses || poses.length === 0) return null;

                const rawKeypoints = poses[0].keypoints;
                
                // Dimens√µes do v√≠deo
                const vw = Motion.video.videoWidth;
                const vh = Motion.video.videoHeight;
                
                // L√≥gica "Cover" para preencher a tela vertical
                const scale = Math.max(width / vw, height / vh);
                const ox = (width - (vw * scale)) / 2;
                const oy = (height - (vh * scale)) / 2;

                // Mapeamento com INVERS√ÉO HORIZONTAL (Espelho)
                const mapPoint = (kp) => ({
                    x: width - (((vw - kp.x) * scale) + ox), // Direita √© Direita
                    y: (kp.y * scale) + oy,
                    score: kp.score,
                    name: kp.name
                });

                const rawMapped = rawKeypoints.map(mapPoint);
                const find = n => rawMapped.find(k => k.name === n);

                // Pontos Chave
                const nose = find('nose');
                const ls = find('left_shoulder');
                const rs = find('right_shoulder');
                const lw = find('left_wrist');
                const rw = find('right_wrist');
                const le = find('left_elbow');
                const re = find('right_elbow');

                // Largura do Corpo (Refer√™ncia de Escala)
                let bodyWidth = 100;
                if (ls.score > 0.3 && rs.score > 0.3) {
                    bodyWidth = Math.hypot(ls.x - rs.x, ls.y - rs.y);
                } else if (Motion.prevPose) {
                    bodyWidth = Motion.prevPose.bodyWidth;
                }

                const currentPose = {
                    nose, 
                    shoulders: { l: ls, r: rs },
                    wrists: { l: lw, r: rw },
                    elbows: { l: le, r: re },
                    center: { x: (ls.x + rs.x)/2, y: (ls.y + rs.y)/2 }, // Centro do peito
                    bodyWidth,
                    dt,
                    velocity: { l: 0, r: 0 } // Velocidade dos pulsos
                };

                // Suaviza√ß√£o e F√≠sica
                if (Motion.prevPose) {
                    // Velocidade (px/sec) normalizada pela largura do corpo
                    const distL = Math.hypot(currentPose.wrists.l.x - Motion.prevPose.rawWrists.l.x, currentPose.wrists.l.y - Motion.prevPose.rawWrists.l.y);
                    const distR = Math.hypot(currentPose.wrists.r.x - Motion.prevPose.rawWrists.r.x, currentPose.wrists.r.y - Motion.prevPose.rawWrists.r.y);
                    
                    currentPose.velocity.l = (distL / dt) / bodyWidth;
                    currentPose.velocity.r = (distR / dt) / bodyWidth;

                    // EMA Smoothing
                    const lerp = (a, b, t) => a + (b - a) * t;
                    const smoothPoint = (curr, prev) => {
                        curr.x = lerp(prev.x, curr.x, Motion.smoothing);
                        curr.y = lerp(prev.y, curr.y, Motion.smoothing);
                    };

                    smoothPoint(currentPose.nose, Motion.prevPose.nose);
                    smoothPoint(currentPose.shoulders.l, Motion.prevPose.shoulders.l);
                    smoothPoint(currentPose.shoulders.r, Motion.prevPose.shoulders.r);
                    smoothPoint(currentPose.wrists.l, Motion.prevPose.wrists.l);
                    smoothPoint(currentPose.wrists.r, Motion.prevPose.wrists.r);
                    smoothPoint(currentPose.center, Motion.prevPose.center);
                }

                // Salvar dados brutos para c√°lculo de velocidade no pr√≥ximo frame
                currentPose.rawWrists = { l: {x: lw.x, y: lw.y}, r: {x: rw.x, y: rw.y} };
                Motion.prevPose = currentPose;

                return currentPose;
            }
        };

        /**
         * =========================================================================
         * 2. GRAPHICS ENGINE (RENDERIZA√á√ÉO)
         * =========================================================================
         */
        const Gfx = {
            canvas: document.getElementById('game-canvas'),
            ctx: null,
            width: 0, height: 0,

            init: () => {
                Gfx.ctx = Gfx.canvas.getContext('2d', { alpha: true });
                window.addEventListener('resize', Gfx.resize);
                Gfx.resize();
            },

            resize: () => {
                const dpr = window.devicePixelRatio || 1;
                Gfx.width = window.innerWidth;
                Gfx.height = window.innerHeight;
                Gfx.canvas.width = Gfx.width * dpr;
                Gfx.canvas.height = Gfx.height * dpr;
                Gfx.ctx.scale(dpr, dpr);
            },

            clear: () => Gfx.ctx.clearRect(0, 0, Gfx.width, Gfx.height),

            // ESQUELETO VISUAL (Obrigat√≥rio em todos os jogos)
            drawSkeleton: (pose, color = '#00F3FF') => {
                if (!pose) return;
                const ctx = Gfx.ctx;
                
                ctx.save();
                ctx.strokeStyle = color;
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;

                const connect = (p1, p2) => {
                    if (p1.score > 0.3 && p2.score > 0.3) {
                        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                    }
                };

                // Corpo
                connect(pose.shoulders.l, pose.shoulders.r);
                connect(pose.shoulders.l, pose.elbows.l);
                connect(pose.elbows.l, pose.wrists.l);
                connect(pose.shoulders.r, pose.elbows.r);
                connect(pose.elbows.r, pose.wrists.r);

                // Cabe√ßa
                if (pose.nose.score > 0.3) {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(pose.nose.x, pose.nose.y, 8, 0, Math.PI*2); ctx.fill();
                }

                // Juntas
                ctx.fillStyle = color;
                [pose.shoulders.l, pose.shoulders.r, pose.elbows.l, pose.elbows.r].forEach(p => {
                    if(p.score > 0.3) { ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill(); }
                });

                ctx.restore();
            }
        };

        /**
         * =========================================================================
         * JOGO 1: TURBO KART (Volante Virtual)
         * =========================================================================
         */
        class GameKart {
            constructor() {
                this.speed = 0;
                this.steering = 0; // -1 a 1
                this.carX = 0; // Posi√ß√£o na pista
                this.roadCurve = 0;
                this.score = 0;
                this.obstacles = [];
                this.handsActive = false;
                
                // Configura√ß√£o HUD
                document.getElementById('hud-gauge-container').classList.remove('hidden');
                document.getElementById('hud-subtext').innerText = "M√ÉOS NO ALTO = VOLANTE";
                App.msg("START!", "#00F3FF");
            }

            update(pose, ctx, w, h) {
                // 1. INPUT: VOLANTE VIRTUAL (Arco tangente entre pulsos)
                let targetSteer = 0;
                this.handsActive = false;

                if (pose.wrists.l.score > 0.4 && pose.wrists.r.score > 0.4) {
                    // Verifica se as m√£os est√£o na metade superior da tela
                    if (pose.wrists.l.y < h * 0.7) {
                        this.handsActive = true;
                        
                        // √Çngulo dos pulsos
                        const dy = pose.wrists.r.y - pose.wrists.l.y;
                        const dx = pose.wrists.r.x - pose.wrists.l.x;
                        const angle = Math.atan2(dy, dx);
                        
                        // Compensa√ß√£o do corpo (para n√£o virar s√≥ de inclinar o tronco)
                        const sDy = pose.shoulders.r.y - pose.shoulders.l.y;
                        const sDx = pose.shoulders.r.x - pose.shoulders.l.x;
                        const bodyAngle = Math.atan2(sDy, sDx);

                        let steer = angle - bodyAngle;
                        
                        // Clamp e Deadzone
                        if (Math.abs(steer) < 0.1) steer = 0;
                        steer = Math.max(-1.2, Math.min(1.2, steer)); // Max rota√ß√£o

                        targetSteer = steer;
                        
                        // Acelerar
                        this.speed = Math.min(150, this.speed + 80 * pose.dt);
                    }
                }

                if (!this.handsActive) {
                    this.speed *= 0.95; // Freio
                    targetSteer = 0; // Centraliza volante
                }

                // Suavizar volante
                this.steering += (targetSteer - this.steering) * 5 * pose.dt;

                // 2. F√çSICA
                this.roadCurve = Math.sin(Date.now() / 1500) * 0.7; // Pista sinuosa
                const turnForce = this.steering * 3.0;
                const centrifugal = this.roadCurve * (this.speed / 100);
                
                this.carX += (turnForce - centrifugal) * pose.dt;
                
                // Limites
                if (this.carX < -1.6) { this.carX = -1.6; this.speed *= 0.9; }
                if (this.carX > 1.6) { this.carX = 1.6; this.speed *= 0.9; }

                this.score += Math.floor(this.speed * pose.dt);

                // Obst√°culos
                if (Math.random() < 0.02 && this.speed > 30) {
                    this.obstacles.push({ x: (Math.random()-0.5)*2.5, z: 0 });
                }

                // 3. RENDERIZA√á√ÉO
                ctx.clearRect(0,0,w,h);
                
                const horizonY = h * 0.4;
                
                // C√©u e Ch√£o
                const grad = ctx.createLinearGradient(0,0,0,h);
                grad.addColorStop(0, '#000022'); grad.addColorStop(1, '#111133');
                ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);

                // Pista
                ctx.fillStyle = '#222';
                ctx.beginPath();
                const centerTop = w/2 + (this.roadCurve * 200);
                const centerBot = w/2 + (this.carX * -300); // Movimento relativo
                const topW = 10;
                const botW = w * 1.5;

                ctx.moveTo(centerTop - topW, horizonY);
                ctx.lineTo(centerTop + topW, horizonY);
                ctx.lineTo(centerBot + botW, h);
                ctx.lineTo(centerBot - botW, h);
                ctx.fill();

                // Linhas da Pista
                ctx.strokeStyle = '#00F3FF'; ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerTop - topW, horizonY); ctx.lineTo(centerBot - botW, h);
                ctx.moveTo(centerTop + topW, horizonY); ctx.lineTo(centerBot + botW, h);
                ctx.stroke();

                // Obst√°culos
                this.obstacles.forEach((obs, i) => {
                    obs.z += (this.speed * 0.002) * pose.dt * 60;
                    if (obs.z > 1.1) { this.obstacles.splice(i,1); return; }

                    const scale = Math.pow(obs.z, 2);
                    const drawY = horizonY + (obs.z * (h - horizonY));
                    const roadX = centerTop + (centerBot - centerTop) * obs.z;
                    const drawX = roadX + (obs.x * w * 0.5 * obs.z);
                    const size = 40 + (100 * scale);

                    ctx.fillStyle = '#FF0055';
                    ctx.fillRect(drawX - size/2, drawY - size, size, size);

                    // Colis√£o
                    if (obs.z > 0.85 && obs.z < 0.95 && Math.abs(drawX - w/2) < 80) {
                        this.speed = 10;
                        App.msg("BATEU!", "#FF0055");
                        ctx.fillStyle = 'white'; ctx.fillRect(0,0,w,h);
                    }
                });

                // Carro
                const carY = h - 150;
                ctx.save();
                ctx.translate(w/2, carY);
                ctx.rotate(this.steering * 0.3); // Inclina√ß√£o visual
                
                // Chassi
                ctx.fillStyle = '#00F3FF';
                ctx.beginPath(); ctx.roundRect(-60, -30, 120, 60, 10); ctx.fill();
                // Vidro
                ctx.fillStyle = '#000'; ctx.fillRect(-50, -40, 100, 25);
                // Luzes
                ctx.fillStyle = '#FF0055';
                ctx.beginPath(); ctx.arc(-45, 0, 12, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(45, 0, 12, 0, Math.PI*2); ctx.fill();
                ctx.restore();

                // Volante Virtual (HUD)
                const wheelY = 150;
                ctx.save();
                ctx.translate(w/2, wheelY);
                ctx.rotate(this.steering);
                
                ctx.beginPath(); ctx.arc(0,0, 70, 0, Math.PI*2);
                ctx.lineWidth = 12; 
                ctx.strokeStyle = this.handsActive ? 'rgba(0, 243, 255, 0.9)' : 'rgba(255,255,255,0.2)';
                ctx.stroke();
                // Raios
                ctx.beginPath(); ctx.moveTo(-70, 0); ctx.lineTo(70, 0); ctx.stroke();
                ctx.restore();

                // Desenha M√£os Virtuais no Volante
                if (this.handsActive) {
                    const lx = w/2 + Math.cos(this.steering + Math.PI)*70;
                    const ly = wheelY + Math.sin(this.steering + Math.PI)*70;
                    const rx = w/2 + Math.cos(this.steering)*70;
                    const ry = wheelY + Math.sin(this.steering)*70;
                    
                    ctx.fillStyle = '#FFFF00';
                    ctx.beginPath(); ctx.arc(lx, ly, 15, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(rx, ry, 15, 0, Math.PI*2); ctx.fill();
                } else {
                    ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.font = "bold 16px sans-serif"; ctx.textAlign = "center";
                    ctx.fillText("SEGURE O VOLANTE", w/2, wheelY + 100);
                }

                // Desenha Esqueleto
                Gfx.drawSkeleton(pose, this.handsActive ? '#00F3FF' : '#555');

                document.getElementById('hud-gauge-fill').style.width = (this.speed/150)*100 + '%';
                return this.score;
            }
        }

        /**
         * =========================================================================
         * JOGO 2: STREET RUN (Corrida de Rua)
         * =========================================================================
         */
        class GameRun {
            constructor() {
                this.score = 0;
                this.speed = 0; 
                this.playerX = 0; 
                this.distance = 0;
                this.playerY = 0;
                this.jumpVel = 0;
                this.obstacles = [];
                this.runEnergy = 0;
                this.lastShoulderY = 0;

                document.getElementById('hud-gauge-container').classList.remove('hidden');
                document.getElementById('hud-subtext').innerText = "CORRA NO LUGAR";
                App.msg("GO!", "#CCFF00");
            }

            update(pose, ctx, w, h) {
                // 1. INPUT
                if (pose.shoulders.l.score > 0.4 && pose.shoulders.r.score > 0.4) {
                    // Posi√ß√£o Lateral (1:1 com corpo)
                    const screenCenter = w / 2;
                    const diffX = pose.center.x - screenCenter;
                    this.playerX = diffX / (pose.bodyWidth * 1.5);
                    this.playerX = Math.max(-1, Math.min(1, this.playerX));

                    // Detec√ß√£o de Corrida (Oscila√ß√£o Vertical do Centro de Massa)
                    if (!this.lastShoulderY) this.lastShoulderY = pose.center.y;
                    const deltaY = Math.abs(pose.center.y - this.lastShoulderY);
                    
                    // Normaliza delta pela altura do corpo
                    const activity = deltaY / pose.bodyWidth;
                    this.lastShoulderY = pose.center.y;

                    // Acumulador de energia
                    if (activity > 0.03) { 
                        this.runEnergy = Math.min(1, this.runEnergy + 2.0 * pose.dt);
                    } else {
                        this.runEnergy = Math.max(0, this.runEnergy - 1.0 * pose.dt);
                    }
                    this.speed = this.runEnergy * 70;

                    // PULO (Impulso Vertical)
                    // Detecta se subiu r√°pido em rela√ß√£o √† m√©dia m√≥vel
                    const velocityY = (pose.velocity.l + pose.velocity.r) / 2; // Bruto das m√£os ajuda a detectar pulo
                    // Se o corpo subiu r√°pido (Delta Y negativo grande)
                    const jumpMetric = (Motion.prevPose.center.y - pose.center.y); // Positivo se subiu
                    
                    if (this.playerY === 0 && jumpMetric > pose.bodyWidth * 0.15) {
                        this.jumpVel = 20;
                        this.playerY = 1;
                        App.msg("PULO!", "#CCFF00");
                    }
                }

                // F√çSICA
                this.distance += this.speed * pose.dt;
                this.score = Math.floor(this.distance * 10);

                // Gravidade
                if (this.playerY > 0) {
                    this.playerY += this.jumpVel * pose.dt * 2;
                    this.jumpVel -= 60 * pose.dt; 
                    if (this.playerY <= 0) { this.playerY = 0; this.jumpVel = 0; }
                }

                // Obst√°culos
                if (Math.random() < 0.02 && this.speed > 5) {
                    this.obstacles.push({ x: (Math.random()-0.5)*1.5, z: 0, type: Math.random()>0.5 ? 'low':'high' });
                }

                // RENDER
                ctx.clearRect(0,0,w,h);
                
                const horizon = h * 0.4;
                ctx.fillStyle = '#050505'; ctx.fillRect(0,0,w,h);
                
                // Ch√£o
                ctx.fillStyle = '#111';
                ctx.beginPath(); ctx.moveTo(w/2, horizon); ctx.lineTo(w*2, h); ctx.lineTo(-w, h); ctx.fill();

                // Grid Cyberpunk
                const gridOffset = (this.distance * 100) % 100;
                ctx.strokeStyle = '#CCFF00'; ctx.lineWidth = 1; ctx.globalAlpha = 0.3;
                ctx.beginPath();
                // Verticais
                ctx.moveTo(w/2, horizon); ctx.lineTo(w*0.2, h);
                ctx.moveTo(w/2, horizon); ctx.lineTo(w*0.5, h);
                ctx.moveTo(w/2, horizon); ctx.lineTo(w*0.8, h);
                // Horizontais
                for(let i=0; i<10; i++) {
                    let y = h - (i*50) + gridOffset;
                    if(y > horizon && y < h) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
                }
                ctx.stroke();
                ctx.globalAlpha = 1.0;

                // Obst√°culos
                this.obstacles.forEach((obs, i) => {
                    obs.z += (this.speed * 0.005 + 0.02) * 60 * pose.dt;
                    if (obs.z > 1.2) { this.obstacles.splice(i,1); return; }

                    const scale = obs.z;
                    const roadW = w * 2 * scale;
                    const drawX = (w/2) + (obs.x * roadW * 0.5);
                    const drawY = horizon + (obs.z * (h - horizon));
                    const size = 50 * scale;

                    ctx.fillStyle = obs.type === 'low' ? '#FFAA00' : '#FF0055';
                    const yOffset = obs.type === 'high' ? size * 1.8 : 0;
                    
                    ctx.shadowBlur = 20; ctx.shadowColor = ctx.fillStyle;
                    ctx.fillRect(drawX - size/2, drawY - size - yOffset, size, size);
                    ctx.shadowBlur = 0;

                    // Colis√£o
                    if (obs.z > 0.85 && obs.z < 0.95) {
                        const dist = Math.abs(drawX - ((w/2) + (this.playerX * w * 0.4)));
                        const hitLow = obs.type === 'low' && this.playerY < 0.5;
                        const hitHigh = obs.type === 'high' && this.playerY > 0.5;
                        
                        if (dist < size && (hitLow || hitHigh)) {
                            this.speed = 0; this.runEnergy = 0;
                            App.msg("CRASH!", "#FF0055");
                            ctx.fillStyle = 'white'; ctx.fillRect(0,0,w,h);
                            this.obstacles.splice(i,1);
                        }
                    }
                });

                // AVATAR AR
                ctx.save();
                const jumpPx = this.playerY * -200;
                ctx.translate(0, jumpPx);
                Gfx.drawSkeleton(pose, '#CCFF00');
                ctx.restore();

                document.getElementById('hud-gauge-fill').style.width = (this.speed/80)*100 + '%';
                return this.score;
            }
        }

        /**
         * =========================================================================
         * JOGO 3: RHYTHM BOX (Boxe de Academia)
         * =========================================================================
         */
        class GameBox {
            constructor() {
                this.score = 0;
                this.combo = 0;
                this.targets = [];
                this.timer = 0;
                this.beatInterval = 1.0; 
                
                document.getElementById('hud-gauge-container').classList.add('hidden');
                document.getElementById('hud-subtext').innerText = "SOQUE AS BOLHAS";
                App.msg("BOXE!", "#FF0055");
            }

            update(pose, ctx, w, h) {
                // 1. SPAWN R√çTMICO
                this.timer += pose.dt;
                if (this.timer > this.beatInterval) {
                    this.timer = 0;
                    const side = Math.random() > 0.5 ? 'L' : 'R';
                    this.targets.push({
                        x: side === 'L' ? w * 0.25 : w * 0.75,
                        y: Math.random() > 0.5 ? h * 0.3 : h * 0.6,
                        radius: 10,
                        active: true,
                        side: side,
                        color: side === 'L' ? '#00F3FF' : '#FF0055',
                        hit: false
                    });
                    this.beatInterval = Math.max(0.5, this.beatInterval * 0.98); 
                }

                // 2. RENDER & COLIS√ÉO
                ctx.clearRect(0,0,w,h);
                
                Gfx.drawSkeleton(pose, '#555', 4); // Esqueleto de fundo

                this.targets.forEach(t => {
                    if (!t.active) return;
                    
                    t.radius += 80 * pose.dt; 
                    const hitZone = 70; // Tamanho ideal

                    // Desenho Alvo
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.radius, 0, Math.PI*2);
                    ctx.fillStyle = t.color + '44'; // Semi-transparente
                    ctx.fill();
                    ctx.lineWidth = 4;
                    ctx.strokeStyle = Math.abs(t.radius - hitZone) < 15 ? '#FFF' : t.color;
                    ctx.stroke();

                    // Detectar Hit (Colis√£o Espacial + Velocidade)
                    if (pose && t.radius > 40 && !t.hit) {
                        const hand = t.side === 'L' ? pose.wrists.l : pose.wrists.r;
                        const velocity = t.side === 'L' ? pose.velocity.l : pose.velocity.r;
                        
                        const dist = Math.hypot(hand.x - t.x, hand.y - t.y);
                        
                        if (dist < t.radius + 30) {
                            if (velocity > 2.0) { // Exige for√ßa no soco
                                t.hit = true;
                                t.active = false;
                                this.combo++;
                                
                                const isStrong = velocity > 5.0;
                                const points = isStrong ? 300 : 100;
                                this.score += points + (this.combo * 10);
                                
                                App.msg(isStrong ? "SMASH!" : "HIT", t.color);
                                
                                // FX
                                ctx.fillStyle = 'white';
                                ctx.beginPath(); ctx.arc(t.x, t.y, 100, 0, Math.PI*2); ctx.fill();
                            }
                        }
                    }

                    // Miss
                    if (t.radius > 110) {
                        t.active = false;
                        this.combo = 0;
                        App.msg("MISS", "#666");
                    }
                });

                this.targets = this.targets.filter(t => t.active);

                // Desenhar Luvas Virtuais
                if (pose) {
                    const drawGlove = (kp, color, vel) => {
                        if (kp.score > 0.3) {
                            const size = 30 + Math.min(25, vel * 3);
                            ctx.shadowBlur = 20; ctx.shadowColor = color;
                            ctx.fillStyle = color;
                            ctx.beginPath(); ctx.arc(kp.x, kp.y, size, 0, Math.PI*2); ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                    };
                    drawGlove(pose.wrists.l, '#00F3FF', pose.velocity.l);
                    drawGlove(pose.wrists.r, '#FF0055', pose.velocity.r);
                }

                return this.score;
            }
        }

        /**
         * =========================================================================
         * 3. APP CONTROLLER
         * =========================================================================
         */
        const App = {
            game: null,
            loopId: null,

            init: async () => {
                Gfx.init();
                const ready = await Motion.init();
                if (ready) {
                    document.getElementById('screen-load').classList.add('hidden');
                    document.getElementById('screen-menu').classList.remove('hidden');
                    document.getElementById('screen-menu').classList.add('flex');
                }
            },

            launch: (type) => {
                document.getElementById('screen-menu').classList.remove('flex');
                document.getElementById('screen-menu').classList.add('hidden');
                document.getElementById('screen-hud').classList.remove('hidden');
                document.getElementById('screen-hud').classList.add('flex');

                if (type === 'kart') App.game = new GameKart();
                if (type === 'run') App.game = new GameRun();
                if (type === 'beat') App.game = new GameBox();

                App.loop();
            },

            stop: () => {
                cancelAnimationFrame(App.loopId);
                App.game = null;
                document.getElementById('screen-hud').classList.add('hidden');
                document.getElementById('screen-menu').classList.remove('hidden');
                document.getElementById('screen-menu').classList.add('flex');
                Gfx.clear();
            },

            msg: (text, color='#FFF') => {
                const el = document.getElementById('hud-msg');
                el.innerText = text;
                el.style.color = color;
                el.style.opacity = 1;
                el.style.transform = "scale(1.2) skewX(-12deg)";
                el.style.textShadow = `0 0 20px ${color}`;
                
                setTimeout(() => {
                    el.style.opacity = 0;
                    el.style.transform = "scale(0.5) skewX(-12deg)";
                }, 600);
            },

            loop: async () => {
                if (!App.game) return;

                const pose = await Motion.update(Gfx.width, Gfx.height);
                if (pose) {
                    const score = App.game.update(pose, Gfx.ctx, Gfx.width, Gfx.height);
                    document.getElementById('hud-score').innerText = score;
                }

                App.loopId = requestAnimationFrame(App.loop);
            }
        };

        window.onload = App.init;

    </script>
    <div style="position: fixed; bottom: 5px; right: 5px; font-size: 8px; color: rgba(255,255,255,0.2); font-family: monospace;">
        Desenvolvido com ü§ñ por thIAguinho Solu√ß√µes
    </div>
</body>
</html>
